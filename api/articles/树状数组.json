{"title":"树状数组","uid":"36ef81d64d1d0edc64820d5afd16a0b4","slug":"树状数组","date":"2026-01-23T16:00:00.000Z","updated":"2026-01-26T21:28:04.895Z","comments":true,"path":"api/articles/树状数组.json","keywords":null,"cover":null,"content":"<h1 id=\"基本内容\"><a href=\"#基本内容\" class=\"headerlink\" title=\"基本内容\"></a>基本内容</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 开全局数组，大小要比题目要求的 N 稍大一点</span></span><br><span class=\"line\"><span class=\"comment\">// tree[] 就是树状数组本体</span></span><br><span class=\"line\"><span class=\"type\">int</span> tree[<span class=\"number\">500005</span>]; </span><br><span class=\"line\"><span class=\"type\">int</span> n; <span class=\"comment\">// 题目给的数组长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 【函数 1】lowbit</span></span><br><span class=\"line\"><span class=\"comment\">// 作用：算出 x 二进制最右边的 1 代表的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &amp; -x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 【函数 2】add (单点修改)</span></span><br><span class=\"line\"><span class=\"comment\">// 作用：把第 x 个数加上 k</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 循环：从 x 开始，每次跳到父亲节点 (i += lowbit(i))</span></span><br><span class=\"line\">    <span class=\"comment\">// 边界：不能超过总长度 n</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = x; i &lt;= n; i += <span class=\"built_in\">lowbit</span>(i)) &#123;</span><br><span class=\"line\">        tree[i] += k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 【函数 3】query (前缀求和)</span></span><br><span class=\"line\"><span class=\"comment\">// 作用：算出 1 到 x 之间所有数的和</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 循环：从 x 开始，每次减掉当前管辖长度 (i -= lowbit(i))</span></span><br><span class=\"line\">    <span class=\"comment\">// 边界：直到 i 变成 0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = x; i &gt; <span class=\"number\">0</span>; i -= <span class=\"built_in\">lowbit</span>(i)) &#123;</span><br><span class=\"line\">        sum += tree[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里add函数用来修改第i个数，query函数用来求部分和。</p>\n<p>不难发现，树状数组中<strong>i每次恰好从最小为1的位上进位</strong>得到的下标是所有包含第i个数的，也就是它全部的上级。<br>那么，对称地，i -&#x3D; lowbit(i)得到的就是全部下级。</p>\n<h1 id=\"从数组a-i-建树的两种方案\"><a href=\"#从数组a-i-建树的两种方案\" class=\"headerlink\" title=\"从数组a[i]建树的两种方案\"></a>从数组a[i]建树的两种方案</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一、</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 先把树状数组清空（如果是全局变量，默认就是0，这步可省）</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(tree, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(tree)); </span><br><span class=\"line\">    <span class=\"comment\">// 2. 借助add函数初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i];    <span class=\"comment\">// 读入原数组</span></span><br><span class=\"line\">        <span class=\"built_in\">add</span>(i, a[i]);   <span class=\"comment\">// 【核心】：直接把值“加”进树状数组</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//二、</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. 先把原数组的值直接抄给 tree</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">       cin &gt;&gt; a[i];</span><br><span class=\"line\">        tree[i] = a[i]; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 按照树形结构，让儿子把值加给父亲</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> father = i + <span class=\"built_in\">lowbit</span>(i); <span class=\"comment\">// 找到它所有的直接上级</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (father &lt;= n) &#123;</span><br><span class=\"line\">            tree[father] += tree[i]; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"访问所有i的子节点\"><a href=\"#访问所有i的子节点\" class=\"headerlink\" title=\"访问所有i的子节点\"></a>访问所有i的子节点</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设我们要找 x 的所有直接儿子</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_children</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> lx = <span class=\"built_in\">lowbit</span>(x); </span><br><span class=\"line\">    <span class=\"comment\">// 遍历所有比 lowbit(x) 小的 2 的幂次</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = <span class=\"number\">1</span>; k &lt; lx; k &lt;&lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> child = x - k;</span><br><span class=\"line\">    <span class=\"comment\">//这里的每个child都是子节点的下标</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">注意，对任意child,只要child + <span class=\"built_in\">lowbit</span>(child) = x,那child就是x的子节点。其中，<span class=\"built_in\">lowbit</span>(child)是<span class=\"number\">2</span>的次方。</span><br><span class=\"line\">所以要找到所有子节点，只要用 x 减去所有比它小的 <span class=\"number\">2</span>的次幂 即可。</span><br></pre></td></tr></table></figure>\n<h1 id=\"一些特性\"><a href=\"#一些特性\" class=\"headerlink\" title=\"一些特性\"></a>一些特性</h1><ul>\n<li>tree[x] 存储的是区间 (x - lowbit(x), x]</li>\n<li>对于一个下标x，重复计算x + lowbit(x)可以得到它的全部上级</li>\n<li>对于一个下标x，记 t &#x3D; x - 2^k ，遍历所有 k ，得到的大于0的t即为其所有直接下级节点</li>\n</ul>\n","text":"基本内容12345678910111213141516171819202122232425262728293031323334// 1. 开全局数组，大小要比题...","permalink":"/post/树状数组","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":12,"path":"api/categories/算法.json"},{"name":"模板","slug":"算法/模板","count":7,"path":"api/categories/算法/模板.json"}],"tags":[{"name":"树状数组","slug":"树状数组","count":2,"path":"api/tags/树状数组.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">基本内容</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E6%95%B0%E7%BB%84a-i-%E5%BB%BA%E6%A0%91%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">从数组a[i]建树的两种方案</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89i%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">访问所有i的子节点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">一些特性</span></a></li></ol>","author":{"name":"LHY","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/256316666?s=400&u=531212165de7b7b90dc6ec2dd44404fc88f4a435&v=4","link":"/","description":"天空中的宝石应该交由天空去寻找","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"线段树","uid":"a448dfd8ebb4408d1633f0dff8411f1c","slug":"线段树及拓展","date":"2026-01-24T16:00:00.000Z","updated":"2026-01-26T21:28:16.403Z","comments":true,"path":"api/articles/线段树及拓展.json","keywords":null,"cover":null,"text":"线段树初步建树函数1234567891011121314151617181920const int maxn = (int)1e5;struct node { ...","permalink":"/post/线段树及拓展","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"算法","slug":"算法","count":12,"path":"api/categories/算法.json"},{"name":"模板","slug":"算法/模板","count":7,"path":"api/categories/算法/模板.json"}],"tags":[{"name":"线段树","slug":"线段树","count":3,"path":"api/tags/线段树.json"},{"name":"DFS","slug":"DFS","count":5,"path":"api/tags/DFS.json"}],"author":{"name":"LHY","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/256316666?s=400&u=531212165de7b7b90dc6ec2dd44404fc88f4a435&v=4","link":"/","description":"天空中的宝石应该交由天空去寻找","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"第24次CCFCSP T4:线段树","uid":"fc6239ad7ae370c627b28fb8b9b9b920","slug":"第24次CCFCSP T4：线段树","date":"2026-01-23T16:00:00.000Z","updated":"2026-01-27T08:45:53.763Z","comments":true,"path":"api/articles/第24次CCFCSP T4：线段树.json","keywords":null,"cover":null,"text":"在AI的辅助下，前前后后花了超过5h时间，终于搞懂了这道题。好消息是，现在应该是从0开始达到了可以熟练应用线段树了。。。顺带还学会了树状数组。 题目链接http...","permalink":"/post/第24次CCFCSP T4：线段树","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"26 mins."},"categories":[{"name":"算法","slug":"算法","count":12,"path":"api/categories/算法.json"},{"name":"CSP真题","slug":"算法/CSP真题","count":2,"path":"api/categories/算法/CSP真题.json"}],"tags":[{"name":"线段树","slug":"线段树","count":3,"path":"api/tags/线段树.json"},{"name":"DFS","slug":"DFS","count":5,"path":"api/tags/DFS.json"}],"author":{"name":"LHY","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/256316666?s=400&u=531212165de7b7b90dc6ec2dd44404fc88f4a435&v=4","link":"/","description":"天空中的宝石应该交由天空去寻找","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}