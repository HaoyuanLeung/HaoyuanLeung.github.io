{"title":"从序数出发：洛谷P10497","uid":"2c254f8ef46716c6896499a3f4302287","slug":"洛谷P10497 从序数出发","date":"2026-01-24T16:00:00.000Z","updated":"2026-01-26T08:14:01.579Z","comments":true,"path":"api/articles/洛谷P10497 从序数出发.json","keywords":null,"cover":null,"content":"<h1 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a>题目链接</h1><p><a href=\"https://www.luogu.com.cn/problem/P10497\">https://www.luogu.com.cn/problem/P10497</a></p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><h2 id=\"暴力做法\"><a href=\"#暴力做法\" class=\"headerlink\" title=\"暴力做法\"></a>暴力做法</h2><p>不难发现，不妨设第一个输入的序数是0。那么最后一个序数表示的是：最后一头牛的编号-1。<br>从最后一头牛逆向递推，主要包含两个查询，<br>1，已经算过编号的牛里，有没有比我这头牛要小的？有的话+1，可以得到一个叠加的delta<br>2，序数+1+前面叠加的delta之后，得到的值是否在已经算出来编号的牛里？是的话，再+1跳过被占用的编号。</p>\n<p><strong>本题的所有做法都基于以上思想，优化则针对两种查询</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[<span class=\"number\">10001</span>],s,st[<span class=\"number\">10001</span>];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[<span class=\"number\">10001</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  cin&gt;&gt;n;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>;i &lt;= n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = n;i &gt;= <span class=\"number\">1</span>;i--)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    s = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>;j &lt;= n;j++)</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(vis[j] == <span class=\"number\">0</span>)</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        s++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s == a[i] + <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          vis[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">          st[i] = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>;i &lt;= n;i++) cout&lt;&lt;st[i]&lt;&lt;<span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线段树\"><a href=\"#线段树\" class=\"headerlink\" title=\"线段树\"></a>线段树</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> sum[MAXN * <span class=\"number\">4</span>]; <span class=\"comment\">// 线段树数组，记得开 4 倍</span></span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"type\">int</span> a[MAXN], ans[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 建树：初始化所有叶子节点为 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> p, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">        sum[p] = <span class=\"number\">1</span>; <span class=\"comment\">// 初始时，每个数字都存在</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(p * <span class=\"number\">2</span>, l, mid);</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(p * <span class=\"number\">2</span> + <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    sum[p] = sum[p * <span class=\"number\">2</span>] + sum[p * <span class=\"number\">2</span> + <span class=\"number\">1</span>]; <span class=\"comment\">// push up</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 核心：查找第 k 小，并将其删掉（减1）</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值是找到的那个数字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query_and_delete</span><span class=\"params\">(<span class=\"type\">int</span> p, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r, <span class=\"type\">int</span> k)</span> </span>&#123;<span class=\"comment\">//同样地，参数意味分别是从第p个节点出发，查询区间[l,r]之间第k小的数字。</span></span><br><span class=\"line\">    sum[p]--; <span class=\"comment\">// 【技巧】因为我们要删掉这个数，所以在路径上直接减 1 即可</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l; <span class=\"comment\">// 找到了，返回具体的数值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> left_cnt = sum[p * <span class=\"number\">2</span>]; <span class=\"comment\">// 左子树里还剩多少个数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k &lt;= left_cnt) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在左边</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">query_and_delete</span>(p * <span class=\"number\">2</span>, l, mid, k);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在右边，注意要减去左边已有的数量</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">query_and_delete</span>(p * <span class=\"number\">2</span> + <span class=\"number\">1</span>, mid + <span class=\"number\">1</span>, r, k - left_cnt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"comment\">// 建树</span></span><br><span class=\"line\">    <span class=\"built_in\">build</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n);</span><br><span class=\"line\">    a[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class=\"line\">    <span class=\"comment\">// 倒序处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n; i &gt;= <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> k = a[i] + <span class=\"number\">1</span>; <span class=\"comment\">// 找剩余数字里的第 k 小</span></span><br><span class=\"line\">        ans[i] = <span class=\"built_in\">query_and_delete</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>, n, k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里，sum数组只是用来标记某个数是否已经被取出，也就是针对查询二。<br>针对查询一，则是通过query_and_delete函数实现</p>\n<h2 id=\"树状数组\"><a href=\"#树状数组\" class=\"headerlink\" title=\"树状数组\"></a>树状数组</h2><p><strong>首先转换成前缀和问题</strong><br>和前面的一样，先把 标记某个数是否已经存在的数组tree[MAXN]设定好（均为0与1），然后转为树状数组<br>那么跟<strong>有k个数比它小</strong>有关的查询，就变成了一个求前缀和的问题，只要找到 前缀和等于k+1 的下标，即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">100005</span>; <span class=\"comment\">// 根据题目要求调整</span></span><br><span class=\"line\"><span class=\"type\">int</span> tree[MAXN]; <span class=\"comment\">// BIT数组</span></span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"type\">int</span> a[MAXN];    <span class=\"comment\">// 存输入的“前面有多少个比它小”</span></span><br><span class=\"line\"><span class=\"type\">int</span> ans[MAXN];  <span class=\"comment\">// 存结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lowbit 操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123; <span class=\"keyword\">return</span> x &amp; -x; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单点修改：让位置 x 的存活状态 +v (1或-1)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; x &lt;= n; x += <span class=\"built_in\">lowbit</span>(x)) tree[x] += v;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 【核心】倍增查找：找到当前第 k 小的可用数字</span></span><br><span class=\"line\"><span class=\"comment\">// 原理：利用二进制拆分，从高位向低位尝试累加</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find_kth</span><span class=\"params\">(<span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> pos = <span class=\"number\">0</span>;       <span class=\"comment\">// 当前确定的位置</span></span><br><span class=\"line\">    <span class=\"type\">int</span> total = <span class=\"number\">0</span>;     <span class=\"comment\">// 当前位置的前缀和</span></span><br><span class=\"line\">    <span class=\"comment\">// 假设 N &lt;= 100000，2^17 &gt; 100000，所以从 17 开始向下枚举</span></span><br><span class=\"line\">    <span class=\"comment\">// 通用写法是 for (int i = 1 &lt;&lt; (int)log2(n); i &gt; 0; i &gt;&gt;= 1)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">17</span>; i &gt; <span class=\"number\">0</span>; i &gt;&gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果跳跃后的位置在范围内，且加上这一段后的总和仍然 &lt; k</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos + i &lt;= n &amp;&amp; total + tree[pos + i] &lt; k) &#123;</span><br><span class=\"line\">            pos += i;            <span class=\"comment\">// 确定这一位是1，位置向前推进</span></span><br><span class=\"line\">            total += tree[pos];  <span class=\"comment\">// 更新已累计的数量</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 循环结束时，pos 是满足 sum &lt; k 的最大位置</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以 pos + 1 就是满足 sum &gt;= k 的第一个位置（即第 k 小）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> pos + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 初始化 BIT：所有数字 1~n 都在，初始值为 1</span></span><br><span class=\"line\">    <span class=\"comment\">// 也可以直接用 O(N) 建树，这里简单用循环 add</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) <span class=\"built_in\">add</span>(i, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 2. 读取输入（题目通常是从第2个开始给，这里假设已处理好下标）</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意：POJ2182第一头牛默认是0，输入一般给 2~N 行</span></span><br><span class=\"line\">    a[<span class=\"number\">1</span>] = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class=\"line\">    <span class=\"comment\">// 3. 倒序处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n; i &gt;= <span class=\"number\">1</span>; i--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// a[i] 表示前面有 a[i] 个比它小</span></span><br><span class=\"line\">        <span class=\"comment\">// 所以它是当前剩余集合中的第 a[i] + 1 小</span></span><br><span class=\"line\">        <span class=\"type\">int</span> k = a[i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 查找第 k 小</span></span><br><span class=\"line\">        <span class=\"type\">int</span> val = <span class=\"built_in\">find_kth</span>(k);</span><br><span class=\"line\">        ans[i] = val;</span><br><span class=\"line\">        <span class=\"comment\">// 删除这个数（权值 -1）</span></span><br><span class=\"line\">        <span class=\"built_in\">add</span>(val, <span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 4. 输出</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过find_kth函数实现了查询一<br>通过实时更新，也就是调用add函数实现查询二</p>\n","feature":true,"text":"题目链接https://www.luogu.com.cn/problem/P10497 题解暴力做法不难发现，不妨设第一个输入的序数是0。那么最后一个序数表示的...","permalink":"/post/洛谷P10497 从序数出发","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"算法","slug":"算法","count":6,"path":"api/categories/算法.json"}],"tags":[{"name":"树状数组","slug":"树状数组","count":2,"path":"api/tags/树状数组.json"},{"name":"线段树","slug":"线段树","count":3,"path":"api/tags/线段树.json"},{"name":"DFS","slug":"DFS","count":5,"path":"api/tags/DFS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">题目链接</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%98%E8%A7%A3\"><span class=\"toc-text\">题解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9A%B4%E5%8A%9B%E5%81%9A%E6%B3%95\"><span class=\"toc-text\">暴力做法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E6%AE%B5%E6%A0%91\"><span class=\"toc-text\">线段树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">树状数组</span></a></li></ol></li></ol>","author":{"name":"LHY","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/256316666?s=400&u=531212165de7b7b90dc6ec2dd44404fc88f4a435&v=4","link":"/","description":"天空中的宝石应该交由天空去寻找","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"线段树","uid":"a448dfd8ebb4408d1633f0dff8411f1c","slug":"线段树及拓展","date":"2026-01-24T16:00:00.000Z","updated":"2026-01-25T22:35:58.645Z","comments":true,"path":"api/articles/线段树及拓展.json","keywords":null,"cover":null,"text":"线段树初步建树函数1234567891011121314151617181920const int maxn = (int)1e5;struct node { ...","permalink":"/post/线段树及拓展","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"板子","slug":"板子","count":2,"path":"api/categories/板子.json"},{"name":"算法","slug":"板子/算法","count":2,"path":"api/categories/板子/算法.json"}],"tags":[{"name":"线段树","slug":"线段树","count":3,"path":"api/tags/线段树.json"},{"name":"DFS","slug":"DFS","count":5,"path":"api/tags/DFS.json"}],"author":{"name":"LHY","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/256316666?s=400&u=531212165de7b7b90dc6ec2dd44404fc88f4a435&v=4","link":"/","description":"天空中的宝石应该交由天空去寻找","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"树状数组","uid":"36ef81d64d1d0edc64820d5afd16a0b4","slug":"树状数组","date":"2026-01-23T16:00:00.000Z","updated":"2026-01-25T13:18:19.564Z","comments":true,"path":"api/articles/树状数组.json","keywords":null,"cover":null,"text":"基本内容12345678910111213141516171819202122232425262728293031323334// 1. 开全局数组，大小要比题...","permalink":"/post/树状数组","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"板子","slug":"板子","count":2,"path":"api/categories/板子.json"},{"name":"算法","slug":"板子/算法","count":2,"path":"api/categories/板子/算法.json"}],"tags":[{"name":"树状数组","slug":"树状数组","count":2,"path":"api/tags/树状数组.json"}],"author":{"name":"LHY","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/256316666?s=400&u=531212165de7b7b90dc6ec2dd44404fc88f4a435&v=4","link":"/","description":"天空中的宝石应该交由天空去寻找","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}