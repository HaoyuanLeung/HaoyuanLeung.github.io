{"title":"FHQ Treap","uid":"6fd4c3b549a94a660b55ba2bdf719c21","slug":"FHQ Treap","date":"2026-01-26T16:00:00.000Z","updated":"2026-01-27T09:07:08.213Z","comments":true,"path":"api/articles/FHQ Treap.json","keywords":null,"cover":null,"content":"<h1 id=\"基础内容\"><a href=\"#基础内容\" class=\"headerlink\" title=\"基础内容\"></a>基础内容</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> MAXN = <span class=\"number\">100005</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> l, r;       <span class=\"comment\">// 左右子节点在数组中的下标</span></span><br><span class=\"line\">    <span class=\"type\">int</span> val;        <span class=\"comment\">// 节点存的数值</span></span><br><span class=\"line\">    <span class=\"type\">int</span> pri;        <span class=\"comment\">// 随机生成的优先级 (Priority)</span></span><br><span class=\"line\">    <span class=\"type\">int</span> size;       <span class=\"comment\">//以此节点为根的子树大小 (用于查询排名)</span></span><br><span class=\"line\">&#125; tr[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> root, idx;      <span class=\"comment\">// root: 树根的下标, idx: 内存池分配指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基础函数 1: 更新子树大小 (Push Up)</span></span><br><span class=\"line\"><span class=\"comment\">// 类似线段树，每次结构改变后都要调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> u)</span> </span>&#123;</span><br><span class=\"line\">    tr[u].size = tr[tr[u].l].size + tr[tr[u].r].size + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基础函数 2: 创建新节点</span></span><br><span class=\"line\"><span class=\"comment\">// 就像生孩子一样，赋予它一个值和一个完全随机的命运(优先级)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">new_node</span><span class=\"params\">(<span class=\"type\">int</span> v)</span> </span>&#123;</span><br><span class=\"line\">    idx++;</span><br><span class=\"line\">    tr[idx].size = <span class=\"number\">1</span>;</span><br><span class=\"line\">    tr[idx].val = v;</span><br><span class=\"line\">    tr[idx].pri = <span class=\"built_in\">rand</span>(); <span class=\"comment\">// 核心：随机性保证了树尽量平衡</span></span><br><span class=\"line\">    tr[idx].l = tr[idx].r = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> idx;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"分裂\"><a href=\"#分裂\" class=\"headerlink\" title=\"分裂\"></a>分裂</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// u: 当前处理的节点</span></span><br><span class=\"line\"><span class=\"comment\">// v: 分割的界限值</span></span><br><span class=\"line\"><span class=\"comment\">// x, y: 引用传递！最后要把分裂出的两个树根“带回去”</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">split</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> v, <span class=\"type\">int</span> &amp;x, <span class=\"type\">int</span> &amp;y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!u) &#123; </span><br><span class=\"line\">        x = y = <span class=\"number\">0</span>; <span class=\"comment\">// 递归到底，空树分裂成两个空树</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[u].val &lt;= v) &#123;</span><br><span class=\"line\">        x = u; <span class=\"comment\">// 当前节点 u 属于左边 (x)</span></span><br><span class=\"line\">        <span class=\"comment\">// 既然 u 已经是 x 了，那 u 的左子树肯定也属于 x，不用动。</span></span><br><span class=\"line\">        <span class=\"comment\">// 我们只需要去切 u 的右子树 (tr[u].r)。</span></span><br><span class=\"line\">        <span class=\"comment\">// 切出来的“小部分”接回 u 的右边，“大部分”作为 y 返回给上一层。</span></span><br><span class=\"line\">        <span class=\"built_in\">split</span>(tr[u].r, v, tr[u].r, y); </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        y = u; <span class=\"comment\">// 当前节点 u 属于右边 (y)</span></span><br><span class=\"line\">        <span class=\"comment\">// 既然 u 已经是 y 了，那 u 的右子树肯定也属于 y，不用动。</span></span><br><span class=\"line\">        <span class=\"comment\">// 我们去切 u 的左子树。</span></span><br><span class=\"line\">        <span class=\"comment\">// 切出来的“小部分”作为 x 返回给上一层，“大部分”接回 u 的左边。</span></span><br><span class=\"line\">        <span class=\"built_in\">split</span>(tr[u].l, v, x, tr[u].l);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">update</span>(u); <span class=\"comment\">// 结构变了，别忘了更新 size</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回合并后的新树根节点编号</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有一棵树是空的，直接返回另一棵</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!x || !y) <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里比较优先级，决定谁当“爸爸”</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[x].pri &lt; tr[y].pri) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// x 的优先级更小（或者是更大，看你定的大小根堆），x 当根</span></span><br><span class=\"line\">        <span class=\"comment\">// x 的左子树不动（因为它最小），</span></span><br><span class=\"line\">        <span class=\"comment\">// 把 x 的右子树 和 y 继续递归合并，接在 x 的右边</span></span><br><span class=\"line\">        tr[x].r = <span class=\"built_in\">merge</span>(tr[x].r, y);</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(x); <span class=\"comment\">// 更新 x 的 size</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// y 的优先级更优，y 当根</span></span><br><span class=\"line\">        <span class=\"comment\">// y 的右子树不动（因为它最大），</span></span><br><span class=\"line\">        <span class=\"comment\">// 把 x 和 y 的左子树 继续递归合并，接在 y 的左边</span></span><br><span class=\"line\">        tr[y].l = <span class=\"built_in\">merge</span>(x, tr[y].l);</span><br><span class=\"line\">        <span class=\"built_in\">update</span>(y); <span class=\"comment\">// 更新 y 的 size</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","feature":true,"text":"基础内容12345678910111213141516171819202122232425262728293031#include <iostream>#inc...","permalink":"/post/FHQ Treap","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"},{"name":"模板","slug":"算法/模板","count":6,"path":"api/categories/算法/模板.json"}],"tags":[{"name":"FHQ Treap","slug":"FHQ-Treap","count":1,"path":"api/tags/FHQ-Treap.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">基础内容</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%86%E8%A3%82\"><span class=\"toc-text\">分裂</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%90%88%E5%B9%B6\"><span class=\"toc-text\">合并</span></a></li></ol>","author":{"name":"LHY","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/256316666?s=400&u=531212165de7b7b90dc6ec2dd44404fc88f4a435&v=4","link":"/","description":"天空中的宝石应该交由天空去寻找","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"ST表","uid":"5e68fa53ca6580310f2a31f4cb78cc8e","slug":"ST表","date":"2026-01-26T16:00:00.000Z","updated":"2026-01-26T21:26:20.438Z","comments":true,"path":"api/articles/ST表.json","keywords":null,"cover":null,"text":"问题引入 给定 个整数，有个询问，对于每个询问，你需要回答区间 中的最大值 暴力做法:每次都对区间 扫描一遍，求出最大值ST表ST数组是该做法的关键，ST[i]...","permalink":"/post/ST表","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"},{"name":"模板","slug":"算法/模板","count":6,"path":"api/categories/算法/模板.json"}],"tags":[{"name":"DP","slug":"DP","count":3,"path":"api/tags/DP.json"},{"name":"ST表","slug":"ST表","count":1,"path":"api/tags/ST表.json"},{"name":"倍增","slug":"倍增","count":1,"path":"api/tags/倍增.json"}],"author":{"name":"LHY","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/256316666?s=400&u=531212165de7b7b90dc6ec2dd44404fc88f4a435&v=4","link":"/","description":"天空中的宝石应该交由天空去寻找","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"优先队列","uid":"b12f8d0edcd683563a684b5335e67e26","slug":"优先队列","date":"2026-01-25T16:00:00.000Z","updated":"2026-01-26T21:08:52.407Z","comments":true,"path":"api/articles/优先队列.json","keywords":null,"cover":null,"text":"声明只能存储指定类型的数据，所以需要声明int/long long/double一类的东西priority_queue<int> pq;或完整地，声明小根堆 1...","permalink":"/post/优先队列","photos":[],"count_time":{"symbolsCount":825,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"},{"name":"模板","slug":"算法/模板","count":6,"path":"api/categories/算法/模板.json"}],"tags":[{"name":"优先队列","slug":"优先队列","count":1,"path":"api/tags/优先队列.json"}],"author":{"name":"LHY","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/256316666?s=400&u=531212165de7b7b90dc6ec2dd44404fc88f4a435&v=4","link":"/","description":"天空中的宝石应该交由天空去寻找","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}