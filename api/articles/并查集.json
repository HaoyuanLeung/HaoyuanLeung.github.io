{"title":"并查集","uid":"c18469ab20e7b093d36b4a61728d07eb","slug":"并查集","date":"2026-01-27T16:00:00.000Z","updated":"2026-01-27T19:01:36.118Z","comments":true,"path":"api/articles/并查集.json","keywords":null,"cover":null,"content":"<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; parent; <span class=\"comment\">// 下标=元素，值=父节点</span></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; rank_;  <span class=\"comment\">// 按秩合并（秩=树的高度），避免树退化成链表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化：n 为元素总数（元素编号通常从 0 或 1 开始，需匹配题目）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    parent.<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">    rank_.<span class=\"built_in\">resize</span>(n, <span class=\"number\">1</span>); <span class=\"comment\">// 初始每个集合的秩为 1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        parent[i] = i; <span class=\"comment\">// 初始每个元素的父节点是自己（根节点）</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">*******</span><br><span class=\"line\"><span class=\"comment\">// 查找：找元素 x 的根节点，带路径压缩（核心优化）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent[x] != x) &#123;</span><br><span class=\"line\">        parent[x] = <span class=\"built_in\">find</span>(parent[x]); <span class=\"comment\">// 递归压缩路径，x 直接指向根</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parent[x]; <span class=\"comment\">// 返回根节点</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">此处，无论最终递归多少次，最终返回的都是输入值x的最终的祖宗</span><br><span class=\"line\">并且，x的所有的爹，都会被赋值这个祖宗，也就是比它高级的都会被赋值</span><br><span class=\"line\">最终用下标代表自己，用parent[x]表示自己的祖宗</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并：合并 x 和 y 所属的集合，按秩合并（核心优化）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unite</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> rx = <span class=\"built_in\">find</span>(x); <span class=\"comment\">// 先找 x 的根</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ry = <span class=\"built_in\">find</span>(y); <span class=\"comment\">// 先找 y 的根</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rx == ry) <span class=\"keyword\">return</span>; <span class=\"comment\">// 已在同一集合，无需合并</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 按秩合并：矮树合并到高树下，减少树的高度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rank_[rx] &lt; rank_[ry]) &#123;</span><br><span class=\"line\">        parent[rx] = ry;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        parent[ry] = rx;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rank_[rx] == rank_[ry]) &#123;</span><br><span class=\"line\">            rank_[rx]++; <span class=\"comment\">// 秩相等时，合并后秩+1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> father[<span class=\"number\">10001</span>];<span class=\"comment\">//并查集数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span><span class=\"comment\">//并查集函数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(father[x]==x)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> father[x]=<span class=\"built_in\">find</span>(father[x]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> c[<span class=\"number\">10001</span>],d[<span class=\"number\">10001</span>],f[<span class=\"number\">10001</span>];<span class=\"comment\">//DP数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n=<span class=\"built_in\">read</span>(),m=<span class=\"built_in\">read</span>(),w=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//初始化并查集</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tfather[i]=i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tc[i]=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">\td[i]=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)<span class=\"comment\">//并查集</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tx=<span class=\"built_in\">read</span>(),y=<span class=\"built_in\">read</span>();</span><br><span class=\"line\">\tfather[<span class=\"built_in\">find</span>(x)]=<span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> <span class=\"comment\">//这里，x和y表示x与y互相是祖宗，所以这里一开始，直觉上写father[y] = x即可</span></span><br><span class=\"line\"> <span class=\"comment\">//但这样的话只能处理单个孤立数据，必须认上一整条链上的祖宗</span></span><br><span class=\"line\"> <span class=\"comment\">//这里表示，把x的另一个祖宗，归为y的祖宗的下属</span></span><br><span class=\"line\"> <span class=\"comment\">//也就是说，以后x和x的另一个祖宗（一开始初始化时候都是自己），都是y的祖宗的后代</span></span><br><span class=\"line\"> <span class=\"comment\">//都是为了便于计算“祖宗和它所有的后代的价钱和价值”</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//将同集合的云朵的价钱与价值都划到一个云朵里</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(father[i]!=i)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t\td[<span class=\"built_in\">find</span>(i)]+=d[i];</span><br><span class=\"line\">\t\td[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tc[<span class=\"built_in\">find</span>(i)]+=c[i];</span><br><span class=\"line\">\t\tc[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//DP</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v=w;v&gt;=c[i];v--)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t    \tf[v]=<span class=\"built_in\">max</span>(f[v],f[v-c[i]]+d[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[w];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","feature":true,"text":"123456789101112131415161718192021222324252627282930313233343536373839vector<int>...","permalink":"/post/并查集","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"},{"name":"模板","slug":"算法/模板","count":6,"path":"api/categories/算法/模板.json"}],"tags":[{"name":"并查集","slug":"并查集","count":1,"path":"api/tags/并查集.json"}],"toc":"","author":{"name":"LHY","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/256316666?s=400&u=531212165de7b7b90dc6ec2dd44404fc88f4a435&v=4","link":"/","description":"天空中的宝石应该交由天空去寻找","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"ST表","uid":"5e68fa53ca6580310f2a31f4cb78cc8e","slug":"ST表","date":"2026-01-26T16:00:00.000Z","updated":"2026-01-26T21:26:20.438Z","comments":true,"path":"api/articles/ST表.json","keywords":null,"cover":null,"text":"问题引入 给定 个整数，有个询问，对于每个询问，你需要回答区间 中的最大值 暴力做法:每次都对区间 扫描一遍，求出最大值ST表ST数组是该做法的关键，ST[i]...","permalink":"/post/ST表","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":11,"path":"api/categories/算法.json"},{"name":"模板","slug":"算法/模板","count":6,"path":"api/categories/算法/模板.json"}],"tags":[{"name":"DP","slug":"DP","count":3,"path":"api/tags/DP.json"},{"name":"ST表","slug":"ST表","count":1,"path":"api/tags/ST表.json"},{"name":"倍增","slug":"倍增","count":1,"path":"api/tags/倍增.json"}],"author":{"name":"LHY","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/256316666?s=400&u=531212165de7b7b90dc6ec2dd44404fc88f4a435&v=4","link":"/","description":"天空中的宝石应该交由天空去寻找","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}