[{"id":"2bdbc871dc8d9490d9e90b4615d9268f","title":"DFS深度优先搜索技术","content":"DFS是一种算法技术，一般通过DFS函数来实现其功能。\nDFS函数的内容1，终止条件2，标记已访问节点3，访问下一层节点，通常该步骤包含DFS函数的递归，且访问完应该注意节点状态更新4，回溯当前节点\n模板12345678910111213141516171819202122232425262728293031/** * 标准 DFS 函数模板 * @param node     当前访问的节点（或当前状态） * @param G        图的邻接表 * @param visited  访问标记数组 */void dfs(int node, vector&lt;vector&lt;int&gt;&gt;&amp; G, vector&lt;bool&gt;&amp; visited) &#123;        // 1. 终止条件 / 基础处理    // (如果是处理树结构，通常在这里判断 node == nullptr)        // 2. 标记当前节点已访问    visited[node] = true;    cout &lt;&lt; &quot;访问节点: &quot; &lt;&lt; node &lt;&lt; endl;     // 3. 遍历邻居节点（选择列表）    for (int neighbor : G[node]) &#123;                // 4. 合法性检查与递归        if (!visited[neighbor]) &#123;                        // 递归进入下一层            dfs(neighbor, G, visited);                        // 5. 回溯 (Backtracking) - 可选            /* 如果是求所有路径或排列组合，               通常在这里执行 visited[neighbor] = false;             */        &#125;    &#125;&#125;","slug":"DFS深度优先搜索技术","date":"2026-01-25T16:00:00.000Z","categories_index":"算法 - DFS","tags_index":"DFS","author_index":"LHY"},{"id":"da3b23123e0ba0b7f168c44a617fc023","title":"DP 动态规划技术","content":"包含两个部分：\n\ndp数组，用来存储”某一种状态”\n数组下标的个数n，表示，该状态由n个独立变量确定\n\n\n状态转移方程，用来表示如何从已有的状态推到现在未知的状态\n\n","slug":"DP 动态规划技术","date":"2026-01-21T16:00:00.000Z","categories_index":"算法 - 动态规划","tags_index":"DP","author_index":"LHY"},{"id":"8577172d587822c13c6c2f341014a5ff","title":"Markdown语法","content":"标题：# title    其中，#的个数即代表为几级标题。\n加粗：**文字**\n列表：- 列表元素 可用缩进表示嵌套列表     1.,2. 即有序数字分隔\n链接：[文字](链接)\n图片：![描述](图片路径)\n\n\n\n\n\n\n\n\n\n如果是网络图片，直接放入其路径即可如果是本地图片，可将图片放入C:\\MyBlog\\source\\images\\文件夹，路径为C:\\MyBlog\\source\\images\\\n引用：&gt; 内容\n代码：```languagetype + code``` or ` code`\n","slug":"Markdown语法","date":"2026-01-21T16:00:00.000Z","categories_index":"一些工具","tags_index":"","author_index":"LHY"},{"id":"9014e3c6b93bd70c6ba3cd7677e22fa6","title":"第23次CCFCSP T4学习笔记","content":"题目链接\n\n\n\n\n\n\n\n\nhttps://www.acwing.com/problem/content/4012/\n题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;const int maxn=50;using namespace std;double p[maxn+5];int book[maxn+5];int N,K;double dp[1000][70000];double dfs(int lev,int left,int state)&#123;//层数，剩余牌数，01选或者不选的状态    if((lev-(N-left))/K&gt;=left)return lev;    double ans=0;    for(int i=0;i&lt;N;i++)&#123;        int temps;        if(book[i]==0)&#123;            book[i]=1;            temps=state|(1&lt;&lt;i);            if(dp[lev+1][temps]==0)&#123;                dp[lev+1][temps]=dfs(lev+1,left-1,temps);            &#125;            ans+=p[i]*dp[lev+1][temps];            book[i]=0;        &#125;        else&#123;            if(dp[lev+1][state]==0)&#123;                dp[lev+1][state]=dfs(lev+1,left,state);            &#125;            ans+=p[i]*dp[lev+1][state];        &#125;    &#125;    return ans;&#125;int main()&#123;    cin&gt;&gt;N&gt;&gt;K;    for(int i=0;i&lt;N;i++)&#123;        cin&gt;&gt;p[i];    &#125;    double ans=0;    for(int i=0;i&lt;N;i++)&#123;        book[i]=1;        int st=(1&lt;&lt;i);        if(dp[1][st]==0)&#123;            dp[1][st]=dfs(1,N-1,st);        &#125;        ans+=p[i]*dfs(1,N-1,st);        book[i]=0;    &#125;    printf(&quot;%.10f&quot;,ans);    return 0;&#125;原文链接://blog.csdn.net/tongjingqi_/article/details/120831527\n算法技术及其实现\n\n\n\n\n\n\n\n\n状态压缩用一个二进制下n位的数字来存储某个包含n个只有0，1子状态的总状态\n对于一个状态i，cpp i = i | (1&lt;&lt;k) 即第k位设为1cpp i = i &amp; ~(1 &lt;&lt; k) 即第k位设为0\ncpp i&gt;&gt;k 该表达式表示第k位的状态，用于访问第k位\n","slug":"第23次CCFCSP T4学习笔记","date":"2026-01-21T16:00:00.000Z","categories_index":"CSP真题","tags_index":"DP,DFS,状态压缩","author_index":"LHY"},{"id":"170e82ce52ebeae7a2973224969d3bd2","title":"桶：值与下标","content":"“桶”（Bucket）通常不是指某一个特定的标准模板库（STL）容器，而是一种思想或数据组织方式。它的核心逻辑是：利用数组下标来代表数据的值（或值的范围），用数组元素来存储该值的属性（如出现次数、存在性等）。\n\n\n\n\n\n\n\n\n\n用途1.搜索  类似map的键，将某个值作为键可以快速查询其相关的属性（值），如存在性、出现次数。\n2.辅助数据结构  在图论中，这种思想是构建复杂结构的基础。    并查集 (Union-Find)：数组 parent[i] &#x3D; k。        含义：下标 i 代表节点 i，值 k 代表它的父节点是 k。这里完全依赖“节点编号”作为数组下标来快速索引。    邻接表 (存储图的数据结构)：vector adj[N]。        含义：adj[u] 存储的是节点 u 的所有邻居。直接用 u 的编号去访问。\n本质即空间换时间。\n\n\n\n\n\n\n\n\n\n补充并查集：关注一个图中节点的连通性，通常用于解决涉及多个节点间是否连通的问题\n123456789101112131415161718192021222324252627282930313233343536373839vector&lt;int&gt; parent; // 下标=元素，值=父节点vector&lt;int&gt; rank_;  // 按秩合并（秩=树的高度），避免树退化成链表// 初始化：n 为元素总数（元素编号通常从 0 或 1 开始，需匹配题目）void init(int n) &#123;    parent.resize(n);    rank_.resize(n, 1); // 初始每个集合的秩为 1    for (int i = 0; i &lt; n; i++) &#123;        parent[i] = i; // 初始每个元素的父节点是自己（根节点）    &#125;&#125;// 查找：找元素 x 的根节点，带路径压缩（核心优化）int find(int x) &#123;    if (parent[x] != x) &#123;        parent[x] = find(parent[x]); // 递归压缩路径，x 直接指向根    &#125;    return parent[x]; // 返回根节点&#125;此处，无论最终递归多少次，最终返回的都是输入值x的最终的祖宗并且，x的所有的爹，都会被赋值这个祖宗，也就是比它高级的都会被赋值最终用下标代表自己，用parent[x]表示自己的祖宗// 合并：合并 x 和 y 所属的集合，按秩合并（核心优化）void unite(int x, int y) &#123;    int rx = find(x); // 先找 x 的根    int ry = find(y); // 先找 y 的根    if (rx == ry) return; // 已在同一集合，无需合并    // 按秩合并：矮树合并到高树下，减少树的高度    if (rank_[rx] &lt; rank_[ry]) &#123;        parent[rx] = ry;    &#125; else &#123;        parent[ry] = rx;        if (rank_[rx] == rank_[ry]) &#123;            rank_[rx]++; // 秩相等时，合并后秩+1        &#125;    &#125;&#125;\n","slug":"桶：值与下标","date":"2026-01-21T16:00:00.000Z","categories_index":"算法","tags_index":"","author_index":"LHY"}]