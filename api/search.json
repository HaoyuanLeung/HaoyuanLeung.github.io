[{"id":"2bdbc871dc8d9490d9e90b4615d9268f","title":"DFS深度优先搜索技术","content":"DFS是一种算法技术，一般通过DFS函数来实现其功能。\nDFS函数的内容1，终止条件2，标记已访问节点3，访问下一层节点，通常该步骤包含DFS函数的递归，且访问完应该注意节点状态更新4，回溯当前节点\n模板12345678910111213141516171819202122232425262728293031/** * 标准 DFS 函数模板 * @param node     当前访问的节点（或当前状态） * @param G        图的邻接表 * @param visited  访问标记数组 */void dfs(int node, vector&lt;vector&lt;int&gt;&gt;&amp; G, vector&lt;bool&gt;&amp; visited) &#123;        // 1. 终止条件 / 基础处理    // (如果是处理树结构，通常在这里判断 node == nullptr)        // 2. 标记当前节点已访问    visited[node] = true;    cout &lt;&lt; &quot;访问节点: &quot; &lt;&lt; node &lt;&lt; endl;     // 3. 遍历邻居节点（选择列表）    for (int neighbor : G[node]) &#123;                // 4. 合法性检查与递归        if (!visited[neighbor]) &#123;                        // 递归进入下一层            dfs(neighbor, G, visited);                        // 5. 回溯 (Backtracking) - 可选            /* 如果是求所有路径或排列组合，               通常在这里执行 visited[neighbor] = false;             */        &#125;    &#125;&#125;","slug":"DFS深度优先搜索技术","date":"2026-01-25T16:00:00.000Z","categories_index":"算法 - DFS","tags_index":"DFS","author_index":"LHY"},{"id":"8577172d587822c13c6c2f341014a5ff","title":"Markdown语法","content":"标题：# title    其中，#的个数即代表为几级标题。\n加粗：**文字**\n列表：- 列表元素 可用缩进表示嵌套列表     1.,2. 即有序数字分隔\n链接：[文字](链接)\n图片：![描述](图片路径)\n\n\n\n\n\n\n\n\n\n如果是网络图片，直接放入其路径即可如果是本地图片，可将图片放入C:\\MyBlog\\source\\images\\文件夹，路径为C:\\MyBlog\\source\\images\\\n引用：&gt; 内容\n代码：```languagetype + code``` or ` code`\n","slug":"Markdown语法","date":"2026-01-21T16:00:00.000Z","categories_index":"一些工具","tags_index":"","author_index":"LHY"},{"id":"da3b23123e0ba0b7f168c44a617fc023","title":"DP 动态规划技术","content":"包含两个部分：\n\ndp数组，用来存储”某一种状态”\n数组下标的个数n，表示，该状态由n个独立变量确定\n\n\n状态转移方程，用来表示如何从已有的状态推到现在未知的状态\n\n","slug":"DP 动态规划技术","date":"2026-01-21T16:00:00.000Z","categories_index":"算法 - 动态规划","tags_index":"DP","author_index":"LHY"},{"id":"9014e3c6b93bd70c6ba3cd7677e22fa6","title":"第23次CCFCSP T4学习笔记","content":"题目链接\n\n\n\n\n\n\n\n\nhttps://www.acwing.com/problem/content/4012/\n题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;const int maxn=50;using namespace std;double p[maxn+5];int book[maxn+5];int N,K;double dp[1000][70000];double dfs(int lev,int left,int state)&#123;//层数，剩余牌数，01选或者不选的状态    if((lev-(N-left))/K&gt;=left)return lev;    double ans=0;    for(int i=0;i&lt;N;i++)&#123;        int temps;        if(book[i]==0)&#123;            book[i]=1;            temps=state|(1&lt;&lt;i);            if(dp[lev+1][temps]==0)&#123;                dp[lev+1][temps]=dfs(lev+1,left-1,temps);            &#125;            ans+=p[i]*dp[lev+1][temps];            book[i]=0;        &#125;        else&#123;            if(dp[lev+1][state]==0)&#123;                dp[lev+1][state]=dfs(lev+1,left,state);            &#125;            ans+=p[i]*dp[lev+1][state];        &#125;    &#125;    return ans;&#125;int main()&#123;    cin&gt;&gt;N&gt;&gt;K;    for(int i=0;i&lt;N;i++)&#123;        cin&gt;&gt;p[i];    &#125;    double ans=0;    for(int i=0;i&lt;N;i++)&#123;        book[i]=1;        int st=(1&lt;&lt;i);        if(dp[1][st]==0)&#123;            dp[1][st]=dfs(1,N-1,st);        &#125;        ans+=p[i]*dfs(1,N-1,st);        book[i]=0;    &#125;    printf(&quot;%.10f&quot;,ans);    return 0;&#125;原文链接://blog.csdn.net/tongjingqi_/article/details/120831527\n算法技术及其实现\n\n\n\n\n\n\n\n\n状态压缩用一个二进制下n位的数字来存储某个包含n个只有0，1子状态的总状态\n对于一个状态i，cpp i = i | (1&lt;&lt;k) 即第k位设为1cpp i = i &amp; ~(1 &lt;&lt; k) 即第k位设为0\ncpp i&gt;&gt;k 该表达式表示第k位的状态，用于访问第k位\n","slug":"第23次CCFCSP T4学习笔记","date":"2026-01-21T16:00:00.000Z","categories_index":"CSP真题","tags_index":"DP,DFS,状态压缩","author_index":"LHY"}]