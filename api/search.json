[{"id":"5e68fa53ca6580310f2a31f4cb78cc8e","title":"ST表","content":"问题引入\n\n\n\n\n\n\n\n\n给定 个整数，有个询问，对于每个询问，你需要回答区间  中的最大值\n暴力做法:每次都对区间  扫描一遍，求出最大值ST表ST数组是该做法的关键，ST[i][j]表示区间[i,i+)范围内的最大值\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXN = 100005;const int MAXLOG = 20;int a[MAXN];int st[MAXN][MAXLOG];int lg2[MAXN]; // 预处理 log2 以加速查询void precompute(int n) {    // 对数预处理    lg2[1] = 0;    for (int i = 2; i &lt;= n; i++)        lg2[i] = lg2[i / 2] + 1;    // 初始状态：长度为 2^0 = 1 的区间最大值就是它本身    for (int i = 1; i &lt;= n; i++)        st[i][0] = a[i];    // 倍增 DP，状态转移    for (int j = 1; j &lt; MAXLOG; j++) {        for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) {            st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1]);        }    }   }int query(int L, int R) {    int k = lg2[R - L + 1];    return max(st[L][k], st[R - (1 &lt;&lt; k) + 1][k]);}int main() {    int n, m;    scanf(\"%d %d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]);    precompute(n);    while (m--) {        int l, r;        scanf(\"%d %d\", &amp;l, &amp;r);        printf(\"%d\\n\", query(l, r));    }    return 0;}\n对于状态转移方程st[i][j] = max(st[i][j - 1], st[i + (1 &lt;&lt; (j - 1))][j - 1])：    st[i][j-1]表示区间[i,i+2^(j-1))上的最大值，而st[i + (1 &lt;&lt; (j - 1))][j-1]表示区间[i+$^(j-1),i+2^j)上的最大值    可以看出来，这个状态转移方程就是把两个区间拼在一起\n复杂度分析precompute函数的时间复杂度是，总空间复杂度也是，但是查询函数query的时间复杂度是惊人的！\n适用条件实际上，此处计算的是区间最大值，也即围绕着max运算进行。那么，对于其他的运算opt，只要满足 x opt x = x则适用ST表。\n注意事项由于这种方法通常用于多次查询，可以针对输入输出进行优化\n123ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n但是，写入后，不能混用cin与scanf，同样也不能使用cout &lt;&lt; endl;应该使用'\\n'换行\n","slug":"ST表","date":"2026-01-26T16:00:00.000Z","categories_index":"算法,模板","tags_index":"ST表,倍增,DP","author_index":"LHY"},{"id":"5ac4f6251c7ad0db188268c01ab9eb97","title":"01字典树与异或","content":"","slug":"01字典树与异或","date":"2026-01-26T16:00:00.000Z","categories_index":"算法,模板","tags_index":"01字典树","author_index":"LHY"},{"id":"b12f8d0edcd683563a684b5335e67e26","title":"优先队列","content":"声明只能存储指定类型的数据，所以需要声明int&#x2F;long long&#x2F;double一类的东西priority_queue&lt;int&gt; pq;或完整地，声明小根堆\n1priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_pq;\n\n成员函数top()查看堆顶元素 O(1)push()插入元素并调整 O(log n)pop()弹出堆顶并调整 O(log n)size()获取元素个数 O(1)empty()判断是否为 O(1)注意，没有clear()函数。\n清空可以用：pq = priority_queue&lt;int&gt;();重新赋值一个空的while(!pq.empty()) pq.pop();全部弹走\ntop()  无     const value_type&amp;push() const value_type&amp; val    voidpop()  无     voidsize()无size_type (通常是 size_t)empty()无     bool\n把一个已有的数组变成堆：\n1234567891011121314vector&lt;int&gt; v;// 默认建立大根堆std::make_heap(v.begin(), v.end());// 建立小根堆std::make_heap(v.begin(), v.end(), std::greater&lt;int&gt;());插入元素x：v.push_back(x);push_heap(v.begin(),v.end());//时间复杂度是Logn取出堆顶部的元素：pop_heap(v.begin(),v.end());//把顶部的元素排到最后面int top = v.back();//取出v.pop_back();//从数列中去掉\n","slug":"优先队列","date":"2026-01-25T16:00:00.000Z","categories_index":"算法,模板","tags_index":"优先队列","author_index":"LHY"},{"id":"2c254f8ef46716c6896499a3f4302287","title":"从序数出发：洛谷P10497","content":"题目链接https://www.luogu.com.cn/problem/P10497\n题解暴力做法不难发现，不妨设第一个输入的序数是0。那么最后一个序数表示的是：最后一头牛的编号-1。从最后一头牛逆向递推，主要包含两个查询，1，已经算过编号的牛里，有没有比我这头牛要小的？有的话+1，可以得到一个叠加的delta2，序数+1+前面叠加的delta之后，得到的值是否在已经算出来编号的牛里？是的话，再+1跳过被占用的编号。\n本题的所有做法都基于以上思想，优化则针对两种查询\n12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[10001],s,st[10001];bool vis[10001];int main()&#123;  cin&gt;&gt;n;  for(int i = 2;i &lt;= n;i++) cin&gt;&gt;a[i];  for(int i = n;i &gt;= 1;i--)  &#123;    s = 0;    for(int j = 1;j &lt;= n;j++)      if(vis[j] == 0)      &#123;        s++;        if(s == a[i] + 1)        &#123;          vis[j] = 1;          st[i] = j;        &#125;      &#125;  &#125;  for(int i = 1;i &lt;= n;i++) cout&lt;&lt;st[i]&lt;&lt;&#x27;\\n&#x27;;  return 0;&#125;\n线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 100005;int sum[MAXN * 4]; // 线段树数组，记得开 4 倍int n;int a[MAXN], ans[MAXN];// 建树：初始化所有叶子节点为 1void build(int p, int l, int r) &#123;    if (l == r) &#123;        sum[p] = 1; // 初始时，每个数字都存在        return;    &#125;    int mid = (l + r) / 2;    build(p * 2, l, mid);    build(p * 2 + 1, mid + 1, r);    sum[p] = sum[p * 2] + sum[p * 2 + 1]; // push up&#125;// 核心：查找第 k 小，并将其删掉（减1）// 返回值是找到的那个数字int query_and_delete(int p, int l, int r, int k) &#123;//同样地，参数意味分别是从第p个节点出发，查询区间[l,r]之间第k小的数字。    sum[p]--; // 【技巧】因为我们要删掉这个数，所以在路径上直接减 1 即可    if (l == r) &#123;        return l; // 找到了，返回具体的数值    &#125;    int mid = (l + r) / 2;    int left_cnt = sum[p * 2]; // 左子树里还剩多少个数    if (k &lt;= left_cnt) &#123;        // 在左边        return query_and_delete(p * 2, l, mid, k);    &#125; else &#123;        // 在右边，注意要减去左边已有的数量        return query_and_delete(p * 2 + 1, mid + 1, r, k - left_cnt);    &#125;&#125;int main() &#123;    ios::sync_with_stdio(false);    cin &gt;&gt; n;    // 建树    build(1, 1, n);    a[1] = 0;    for (int i = 2; i &lt;= n; i++) cin &gt;&gt; a[i];    // 倒序处理    for (int i = n; i &gt;= 1; i--) &#123;        int k = a[i] + 1; // 找剩余数字里的第 k 小        ans[i] = query_and_delete(1, 1, n, k);    &#125;    for (int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;    return 0;&#125;\n这里，sum数组只是用来标记某个数是否已经被取出，也就是针对查询二。针对查询一，则是通过query_and_delete函数实现\n树状数组首先转换成前缀和问题和前面的一样，先把 标记某个数是否已经存在的数组tree[MAXN]设定好（均为0与1），然后转为树状数组那么跟有k个数比它小有关的查询，就变成了一个求前缀和的问题，只要找到 前缀和等于k+1 的下标，即可\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100005; // 根据题目要求调整int tree[MAXN]; // BIT数组int n;int a[MAXN];    // 存输入的“前面有多少个比它小”int ans[MAXN];  // 存结果// lowbit 操作int lowbit(int x) &#123; return x &amp; -x; &#125;// 单点修改：让位置 x 的存活状态 +v (1或-1)void add(int x, int v) &#123;    for (; x &lt;= n; x += lowbit(x)) tree[x] += v;&#125;// 【核心】倍增查找：找到当前第 k 小的可用数字// 原理：利用二进制拆分，从高位向低位尝试累加int find_kth(int k) &#123;    int pos = 0;       // 当前确定的位置    int total = 0;     // 当前位置的前缀和    // 假设 N &lt;= 100000，2^17 &gt; 100000，所以从 17 开始向下枚举    // 通用写法是 for (int i = 1 &lt;&lt; (int)log2(n); i &gt; 0; i &gt;&gt;= 1)    for (int i = 1 &lt;&lt; 17; i &gt; 0; i &gt;&gt;= 1) &#123;        // 如果跳跃后的位置在范围内，且加上这一段后的总和仍然 &lt; k        if (pos + i &lt;= n &amp;&amp; total + tree[pos + i] &lt; k) &#123;            pos += i;            // 确定这一位是1，位置向前推进            total += tree[pos];  // 更新已累计的数量        &#125;    &#125;    // 循环结束时，pos 是满足 sum &lt; k 的最大位置    // 所以 pos + 1 就是满足 sum &gt;= k 的第一个位置（即第 k 小）    return pos + 1;&#125;int main() &#123;    ios::sync_with_stdio(false);    cin &gt;&gt; n;    // 1. 初始化 BIT：所有数字 1~n 都在，初始值为 1    // 也可以直接用 O(N) 建树，这里简单用循环 add    for (int i = 1; i &lt;= n; i++) add(i, 1);    // 2. 读取输入（题目通常是从第2个开始给，这里假设已处理好下标）    // 注意：POJ2182第一头牛默认是0，输入一般给 2~N 行    a[1] = 0;     for (int i = 2; i &lt;= n; i++) cin &gt;&gt; a[i];    // 3. 倒序处理    for (int i = n; i &gt;= 1; i--) &#123;        // a[i] 表示前面有 a[i] 个比它小        // 所以它是当前剩余集合中的第 a[i] + 1 小        int k = a[i] + 1;        // 查找第 k 小        int val = find_kth(k);        ans[i] = val;        // 删除这个数（权值 -1）        add(val, -1);    &#125;    // 4. 输出    for (int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;    return 0;&#125;\n通过find_kth函数实现了查询一通过实时更新，也就是调用add函数实现查询二\n","slug":"洛谷P10497 从序数出发","date":"2026-01-24T16:00:00.000Z","categories_index":"算法","tags_index":"树状数组,DFS,线段树","author_index":"LHY"},{"id":"a448dfd8ebb4408d1633f0dff8411f1c","title":"线段树","content":"线段树初步建树函数1234567891011121314151617181920const int maxn = (int)1e5;struct node &#123;    int l, r, v;&#125; a[maxn &lt;&lt; 2];//因为线段树的高度是log_2 n,总占用需要最多4n，这里尽量往大了开。int num[maxn];void build(int id, int l, int r) &#123;    a[id].l = l;    a[id].r = r;    if (l == r) &#123;        a[id].v = num[l];        return;    &#125;    int mid = l + r &gt;&gt; 1;    build(id &lt;&lt; 1, l, mid);    build(id &lt;&lt; 1 | 1, mid + 1, r);//分别等价于 *2 与 *2+1    a[id].v = a[id &lt;&lt; 1].v + a[id &lt;&lt; 1 | 1].v;    return;&#125;\n修改某些节点上的值方案一：给某个节点赋值\n12345678910111213141516171819202122232425262728//赋值函数void opt_1(int id, int k, int v) &#123;//id是从第id个节点出发，k是想要修改的点的位置（后面递归的部分实际上是二分），v是希望给这个点赋的值    int l = a[id].l;    int r = a[id].r;    if (l == r) &#123;        a[id].v = v;        return;    &#125;    int mid = l + r &gt;&gt; 1;    if (mid &lt; k) opt_1(id &lt;&lt; 1 | 1, k, v);    else opt_1(id &lt;&lt; 1, k, v);    a[id].v = a[id &lt;&lt; 1].v + a[id &lt;&lt; 1 | 1].v;    return;&#125;int opt_2(int id, int tgtl, int tgtr) &#123;//调用这个函数，id一般得是根节点的下标（避免一开始节点的区间就被包裹）    //后面两个参数分别是区间的左右边界    //返回值为一个从tgtl到tgtr的部分和    int l = a[id].l;    int r = a[id].r;    if (tgtl &lt;= l &amp;&amp; r &lt;= tgtr) return a[id].v;    int mid = l + r &gt;&gt; 1;    if (mid &gt;= tgtr) return opt_2(id &lt;&lt; 1, tgtl, tgtr);    else if (mid &lt; tgtl) return opt_2(id &lt;&lt; 1 | 1, tgtl, tgtr);    return opt_2(id &lt;&lt; 1, tgtl, tgtr) + opt_2(id &lt;&lt; 1 | 1, tgtl, tgtr);&#125;//中间的if和else if是一个二分，即判断是往左走还是往右走//最关键的是最后一个return。通过这一行可以把零碎的子区间拼凑成需要的区间\n\n方案二：给区间赋值\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263    //1，首先给每个节点增加一个成员    struct node &#123;        int l, r;        long long v;   // 区间和        long long tag; // 标记：存储其每个下属节点需要加上的值    &#125; a[maxn &lt;&lt; 2];    //2，分发函数：访问子节点前，把父节点的债（tag）分发给两个孩子。    void push_down(int id) &#123;        // 如果当前节点有标记（tag不为0）        if (a[id].tag != 0) &#123;            int left = id &lt;&lt; 1;      // 左孩子下标                int right = id &lt;&lt; 1 | 1; // 右孩子下标            long long t = a[id].tag; // 取出标记值            // 1. 更新左孩子的数值和标记            // 左孩子的新值 = 旧值 + 增加量 * 区间长度            a[left].v += t * (a[left].r - a[left].l + 1);            a[left].tag += t; // 累加标记            // 2. 更新右孩子的数值和标记            a[right].v += t * (a[right].r - a[right].l + 1);            a[right].tag += t;            // 3. 清空当前节点的标记（债已还清）            a[id].tag = 0;            &#125;    &#125;    //3，修改区间值    // id:当前节点, [l,r]:修改的目标区间, val:要增加的值    void update(int id, int l, int r, int val) &#123;        int L = a[id].l;        int R = a[id].r;        // 情况1：当前节点区间完全被目标区间包含        // 直接修改当前节点，打上标记，不再向下        if (l &lt;= L &amp;&amp; R &lt;= r) &#123;            a[id].v += (long long)val * (R - L + 1); // 更新当前节点的总和            a[id].tag += val;                        // 打上标记        return;        &#125;        // 情况2：不完全包含，需要向下递归        // 【关键】：在分叉之前，必须先把身上的标记推下去！        push_down(id);        int mid = (L + R) &gt;&gt; 1;        if (l &lt;= mid) update(id &lt;&lt; 1, l, r, val);      // 涉及左边就去左边        if (r &gt; mid)  update(id &lt;&lt; 1 | 1, l, r, val);  // 涉及右边就去右边        // 回溯：更新父节点的值 (Push Up)        a[id].v = a[id &lt;&lt; 1].v + a[id &lt;&lt; 1 | 1].v;    &#125;    //4，区间查询        long long query(int id, int l, int r) &#123;//这个函数的功能是，从下标为id的结点出发，查询区间[l,r]的总和        int L = a[id].l;        int R = a[id].r;        if (l &lt;= L &amp;&amp; R &lt;= r) &#123;            return a[id].v;        &#125;        // 【关键】：查询之前也要推标记        push_down(id);        int mid = (L + R) &gt;&gt; 1;        long long res = 0;        if (l &lt;= mid) res += query(id &lt;&lt; 1, l, r);//这个地方通过累加实现区间的分割        if (r &gt; mid)  res += query(id &lt;&lt; 1 | 1, l, r);        return res;&#125;\n\n动态开点数据结构设计123456789101112131415161718//全局计数器int cnt = 0; // 代表当前用到了第几个节点int root;struct node&#123;    int ls,rs;//左右子节点的下标    long long val;//节点需要存储的属性，可以开多几个也没关系。    long long tag;//标记&#125;int new_node()&#123;//把生成新节点的部分独立出来，调用一次这个函数就cnt++，防止混淆    ++cnt;    tree[cnt].ls = 0;    tree[cnt].rs = 0;    tree[cnt].val = 0;    tree[cnt].tag = 0;    return cnt;&#125;\n基础功能函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879801，更新父节点的值//从下标为p的节点出发遍历它的后代，以达到更新自己的目的void push_up(int p) &#123;    // 注意：如果孩子不存在(是0)，那么那边的值就是0    // tree[0] 全局默认为0，所以直接加也没问题，但写清楚更好    long long left_val = (tree[p].ls ? tree[tree[p].ls].val : 0);    long long right_val = (tree[p].rs ? tree[tree[p].rs].val : 0);    tree[p].val = left_val + right_val;&#125;2，tags向下传递//对于tags的传递，普通线段树由于下标都是固定的比较方便，对于动态开点的线段树需要特殊的处理方法void push_down(int p, int l, int r) &#123;    if (tree[p].tag == 0) return; // 没有标记，不用下传    int mid = l + (r - l) / 2;    long long t = tree[p].tag;    // --- 左边 ---    if (!tree[p].ls) tree[p].ls = new_node(); // 1. 没了就建    int ls = tree[p].ls;    tree[ls].val += t * (mid - l + 1);        // 2. 更新数值    tree[ls].tag += t;                        // 3. 传递标记    // --- 右边 ---    if (!tree[p].rs) tree[p].rs = new_node(); // 1. 没了就建    int rs = tree[p].rs;    tree[rs].val += t * (r - mid);            // 2. 更新数值    tree[rs].tag += t;                        // 3. 传递标记    // --- 清空父节点 ---    tree[p].tag = 0;&#125;3，区间修改//区间修改：将区间 [ql, qr] 内所有数都 + kvoid update(int &amp;p, int l, int r, int ql, int qr, int k) &#123;    // 如果 p 还是 0（说明这里从来没被访问过），先建个号    if (!p) p = new_node();    // 1. 完全包含：直接改自己，打条子，走人    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;        tree[p].val += (long long)k * (r - l + 1);        tree[p].tag += k;        return;    &#125;    // 2. 不完全包含：先下放标记，再分头行动    push_down(p, l, r);    int mid = l + (r - l) / 2;    if (ql &lt;= mid) update(tree[p].ls, l, mid, ql, qr, k);    if (qr &gt; mid)  update(tree[p].rs, mid + 1, r, ql, qr, k);    // 3. 孩子变了，重新算自己的总帐    push_up(p);&#125;4，部分和查询//区间查询：查询[ql, qr]的和long long query(int p, int l, int r, int ql, int qr) &#123;    // 如果节点不存在，或者区间没交集，那就是 0    if (!p) return 0;    // 1. 完全包含：直接返回    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;        return tree[p].val;    &#125;    // 2. 要往下查，记得先推标记！否则孩子的数据是旧的    push_down(p, l, r);         int mid = l + (r - l) / 2;    long long res = 0;    if (ql &lt;= mid) res += query(tree[p].ls, l, mid, ql, qr);    if (qr &gt; mid)  res += query(tree[p].rs, mid + 1, r, ql, qr);    return res;&#125;","slug":"线段树及拓展","date":"2026-01-24T16:00:00.000Z","categories_index":"算法,模板","tags_index":"DFS,线段树","author_index":"LHY"},{"id":"36ef81d64d1d0edc64820d5afd16a0b4","title":"树状数组","content":"基本内容12345678910111213141516171819202122232425262728293031323334// 1. 开全局数组，大小要比题目要求的 N 稍大一点// tree[] 就是树状数组本体int tree[500005]; int n; // 题目给的数组长度// ------------------------------------------// 【函数 1】lowbit// 作用：算出 x 二进制最右边的 1 代表的值int lowbit(int x) &#123;    return x &amp; -x;&#125;// 【函数 2】add (单点修改)// 作用：把第 x 个数加上 kvoid add(int x, int k) &#123;    // 循环：从 x 开始，每次跳到父亲节点 (i += lowbit(i))    // 边界：不能超过总长度 n    for (int i = x; i &lt;= n; i += lowbit(i)) &#123;        tree[i] += k;    &#125;&#125;// 【函数 3】query (前缀求和)// 作用：算出 1 到 x 之间所有数的和int query(int x) &#123;    int sum = 0;    // 循环：从 x 开始，每次减掉当前管辖长度 (i -= lowbit(i))    // 边界：直到 i 变成 0    for (int i = x; i &gt; 0; i -= lowbit(i)) &#123;        sum += tree[i];    &#125;    return sum;&#125;\n\n这里add函数用来修改第i个数，query函数用来求部分和。\n不难发现，树状数组中i每次恰好从最小为1的位上进位得到的下标是所有包含第i个数的，也就是它全部的上级。那么，对称地，i -&#x3D; lowbit(i)得到的就是全部下级。\n从数组a[i]建树的两种方案123456789101112131415161718192021//一、    // 1. 先把树状数组清空（如果是全局变量，默认就是0，这步可省）    memset(tree, 0, sizeof(tree));     // 2. 借助add函数初始化    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; a[i];    // 读入原数组        add(i, a[i]);   // 【核心】：直接把值“加”进树状数组    &#125;//二、    // 1. 先把原数组的值直接抄给 tree    for (int i = 1; i &lt;= n; i++) &#123;       cin &gt;&gt; a[i];        tree[i] = a[i];     &#125;    // 2. 按照树形结构，让儿子把值加给父亲    for (int i = 1; i &lt;= n; i++) &#123;        int father = i + lowbit(i); // 找到它所有的直接上级        if (father &lt;= n) &#123;            tree[father] += tree[i];         &#125;    &#125;\n\n访问所有i的子节点123456789101112// 假设我们要找 x 的所有直接儿子void get_children(int x) &#123;    int lx = lowbit(x);     // 遍历所有比 lowbit(x) 小的 2 的幂次    for (int k = 1; k &lt; lx; k &lt;&lt;= 1) &#123;        int child = x - k;    //这里的每个child都是子节点的下标    &#125;&#125;注意，对任意child,只要child + lowbit(child) = x,那child就是x的子节点。其中，lowbit(child)是2的次方。所以要找到所有子节点，只要用 x 减去所有比它小的 2的次幂 即可。\n一些特性\ntree[x] 存储的是区间 (x - lowbit(x), x]\n对于一个下标x，重复计算x + lowbit(x)可以得到它的全部上级\n对于一个下标x，记 t &#x3D; x - 2^k ，遍历所有 k ，得到的大于0的t即为其所有直接下级节点\n\n","slug":"树状数组","date":"2026-01-23T16:00:00.000Z","categories_index":"算法,模板","tags_index":"树状数组","author_index":"LHY"},{"id":"fc6239ad7ae370c627b28fb8b9b9b920","title":"第24次CCFCSP T4:线段树","content":"在AI的辅助下，前前后后花了超过5h时间，终于搞懂了这道题。好消息是，现在应该是从0开始达到了可以熟练应用线段树了。。。顺带还学会了树状数组。\n题目链接https://www.acwing.com/problem/content/description/4286/\n能过部分样例的一个解答代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,k,cnt;struct nodes{    int ls=0,rs=0;//左右节点下标    int id=0;int val=0;    int id_last=0;};vector&lt;nodes&gt; node;int newnode(){    ++cnt;    nodes a;    node.push_back(a);    return cnt;}void pushdown(int i,int l,int r){    if((node[i].id==-1)||(node[i].id==0&amp;&amp;node[i].val==0&amp;&amp;node[i].id_last==0)) return;    if(!node[i].ls) node[i].ls = newnode();    if(!node[i].rs)  node[i].rs = newnode();    int ls = node[i].ls;int rs = node[i].rs;    node[ls].id = node[i].id;node[ls].val = node[i].val;node[ls].id_last = node[i].id_last;    node[rs].id = node[i].id;node[rs].val = node[i].val;node[rs].id_last = node[i].id_last;    node[i].id = -1;}void update(int i,int l,int r,int id,int ll,int rr,int x){    if(ll&lt;=l&amp;&amp;r&lt;=rr){        node[i].id = id;node[i].val = x;        return;    }    else{                pushdown(i,l,r);        int mid = l+(r-l)/2;        if (ll &lt;= mid){             if (!node[i].ls) node[i].ls = newnode();            int ls = node[i].ls;            update(ls,l,mid,id,ll,rr,x);        }        if(mid&lt;rr){            if (!node[i].rs) node[i].rs = newnode();            int rs = node[i].rs;            update(rs,mid+1,r,id,ll,rr,x);        }        node[i].id = -1;    }}bool search1_x(int i,int l,int r,int id,int ll,int rr){//查找指定区间上的节点的id是否是指定id    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if(node[i].id==id) return true;        else if(node[i].id!=-1) return false;    }          pushdown(i,l,r);    int mid = l+(r-l)/2;    bool llv=false,rrv=false,lll=false,rrr=false;    if(mid&gt;=ll){        if(!node[i].ls) node[i].ls = newnode();        int ls=node[i].ls;        llv = search1_x(ls,l,mid,id,ll,rr);if(!llv) return false;        lll=true;    }    if(mid&lt;rr){        if(!node[i].rs) node[i].rs = newnode();        int rs=node[i].rs;        rrv = search1_x(rs,mid+1,r,id,ll,rr);if(!rrv) return false;        rrr=true;    }    bool jud1=false,jud2=false;    if((llv&amp;&amp;lll)||((!llv)&amp;&amp;(!lll))) jud1=true;    if((rrv&amp;&amp;rrr)||((!rrv)&amp;&amp;(!rrr))) jud2=true;    return jud1&amp;&amp;jud2;}void delete_x(int i,int l,int r,int id,int ll,int rr){        if(ll&lt;=l&amp;&amp;r&lt;=rr){            node[i].id = 0;            node[i].id_last = id;        }        else{            pushdown(i,l,r);            int mid = l+(r-l)/2;            if(mid&gt;=ll){                if(!node[i].ls) node[i].ls = newnode();                int ls=node[i].ls;                delete_x(ls,l,mid,id,ll,rr);            }            if(mid&lt;rr){                if(!node[i].rs) node[i].rs = newnode();                int rs=node[i].rs;                delete_x(rs,mid+1,r,id,ll,rr);            }            node[i].id = -1;        }}bool search2_x(int i,int l,int r,int id,int ll,int rr){//查找指定区间上的节点的id是否是空的    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if(node[i].id==0&amp;&amp;node[i].id_last==id) return true;        else if(node[i].id!=-1) return false;    }    pushdown(i,l,r);    int mid = l+(r-l)/2;    bool llv=false,rrv=false,lll=false,rrr=false;    if(mid&gt;=ll){        if(!node[i].ls) node[i].ls = newnode();        int ls=node[i].ls;        llv = search2_x(ls,l,mid,id,ll,rr);if(!llv) return false;        lll=true;    }    if(mid&lt;rr){        if(!node[i].rs) node[i].rs = newnode();        int rs=node[i].rs;        rrv = search2_x(rs,mid+1,r,id,ll,rr);if(!rrv) return false;        rrr=true;    }    bool jud1=false,jud2=false;    if((llv&amp;&amp;lll)||((!llv)&amp;&amp;(!lll))) jud1=true;    if((rrv&amp;&amp;rrr)||((!rrv)&amp;&amp;(!rrr))) jud2=true;    return jud1&amp;&amp;jud2;    }void revive_x(int i,int l,int r,int id,int ll,int rr){        if(ll&lt;=l&amp;&amp;r&lt;=rr){            node[i].id=id;            node[i].id_last=0;        }        else{            pushdown(i,l,r);            int mid = l+(r-l)/2;            if(mid&gt;=ll){                if(!node[i].ls) node[i].ls = newnode();                int ls=node[i].ls;                revive_x(ls,l,mid,id,ll,rr);            }            if(mid&lt;rr){                if(!node[i].rs) node[i].rs = newnode();                int rs=node[i].rs;                revive_x(rs,mid+1,r,id,ll,rr);            }            node[i].id = -1;        }}pair&lt;int,int&gt; search_x(int i,int l,int r,int ll,int rr){    pair&lt;int,int&gt; a;    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if(node[i].id){            a.first=node[i].id;a.second=node[i].val;        }        else{            a.first=0;a.second=0;        }    }    else{        pushdown(i,l,r);        int mid = l+(r-l)/2;        if(mid&gt;=ll){            if(!node[i].ls) node[i].ls = newnode();            int ls=node[i].ls;            a = search_x(ls,l,mid,ll,rr);        }        if(mid&lt;rr){            if(!node[i].rs) node[i].rs = newnode();            int rs=node[i].rs;            a = search_x(rs,mid+1,r,ll,rr);        }    }    return a;}bool search3_x(int i,int l,int r,int id,int ll,int rr){//查找指定区间上的节点的id是否是指定id或者0    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if(node[i].id==id||node[i].id==0) return true;        else if(node[i].id==-1){            int mid = l+(r-l)/2;            int ls  = node[i].ls;int rs = node[i].rs;            return (search3_x(ls,l,mid,id,ll,rr)&amp;&amp;search3_x(rs,mid+1,r,id,ll,rr));        }        else return false;    }    else{                pushdown(i,l,r);        int mid = l+(r-l)/2;        bool llv=false,rrv=false,lll=false,rrr=false;        if(mid&gt;=ll){            if(!node[i].ls) node[i].ls = newnode();            int ls=node[i].ls;            llv = search3_x(ls,l,mid,id,ll,rr);if(!llv) return false;            lll=true;        }        if(mid&lt;rr){            if(!node[i].rs) node[i].rs = newnode();            int rs=node[i].rs;            rrv = search3_x(rs,mid+1,r,id,ll,rr);if(!rrv) return false;            rrr=true;        }        bool jud1=false,jud2=false;        if((llv&amp;&amp;lll)||((!llv)&amp;&amp;(!lll))) jud1=true;        if((rrv&amp;&amp;rrr)||((!rrv)&amp;&amp;(!rrr))) jud2=true;        return jud1&amp;&amp;jud2;    }}int find_limit(int i,int l,int r,int id,int ll,int rr){//查找[ll,rr]区间上，第一个不是指定id的下标    if(i==0) return -1;    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if(node[i].id!=id&amp;&amp;node[i].id!=-1&amp;&amp;node[i].id!=0) return l;        else if(node[i].id==-1){            int mid = l + (r-l)/2;            int ls = node[i].ls;int rs = node[i].rs;            if(find_limit(ls,l,mid,id,ll,rr)==-1){                return find_limit(rs,mid+1,r,id,ll,rr);            }            else return find_limit(ls,l,mid,id,ll,rr);        }        else return -1;    }    else{           int mid = l+(r-l)/2;        int ls = node[i].ls;int rs = node[i].rs;        int a1 = find_limit(ls,l,mid,id,ll,rr);        if(ll&gt;mid) a1=-1;        if(a1 == -1){            int a2 = find_limit(rs,mid+1,r,id,ll,rr);            return a2;        }        else return a1;    }}int main(){     cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    nodes dummy;     node.push_back(dummy);    newnode();    while(k--){    int c;cin&gt;&gt;c;    if(c==0){        int id,l,r,x;cin&gt;&gt;id&gt;&gt;l&gt;&gt;r&gt;&gt;x;        if(search3_x(1,1,m,id,l,r)){            update(1,1,m,id,l,r,x);            cout&lt;&lt;r&lt;&lt;endl;        }        else{            int t = find_limit(1,1,m,id,l,r);            if(t-1&lt;l){                cout&lt;&lt;-1&lt;&lt;endl;            }            else{                update(1,1,m,id,l,t-1,x);                cout&lt;&lt;t-1&lt;&lt;endl;            }        }    }    else if(c==1){        int id,l,r;cin&gt;&gt;id&gt;&gt;l&gt;&gt;r;        if(search1_x(1,1,m,id,l,r)){            cout&lt;&lt;\"OK\"&lt;&lt;endl;            delete_x(1,1,m,id,l,r);        }        else cout&lt;&lt;\"FAIL\"&lt;&lt;endl;    }    else if(c==2){        int id,l,r;cin&gt;&gt;id&gt;&gt;l&gt;&gt;r;        if(search2_x(1,1,m,id,l,r)){            cout&lt;&lt;\"OK\"&lt;&lt;endl;            revive_x(1,1,m,id,l,r);        }        else cout&lt;&lt;\"FAIL\"&lt;&lt;endl;    }    else{        int p;cin&gt;&gt;p;        pair&lt;int,int&gt; a = search_x(1,1,m,p,p);        cout&lt;&lt;a.first&lt;&lt;\" \"&lt;&lt;a.second&lt;&lt;endl;    }    }    return 0;}\n复杂度分析最坏情况下，空间复杂度大概是 ，时间复杂度大概是，这个就是超时的原因。\n一些细节1，由于是动态开点，需要一个全局计数器cnt来记录对应的节点索引。同时，把新建节点封装进newcode()函数里，这样也省的一边要维护node数组一边维护计数器。\n2，pushdown函数。    由于在需要树枝分叉时，有一些属性需要从父节点传递到子节点，这里使用pushdown函数来完成这个功能。但是，传递之后，有些属性出现分化，比如左子节点的id不等于右子节点的id，这种时候就需要把父节点的id修改成特殊值-1。实际上，这个-1在后续维护其他函数的过程中造成了非常大的麻烦，但这一步又省不掉，非常之麻烦。。\n3，其他的函数没什么可说的，基本上都是用了DFS的方法实现了所需要的一些操作。\n4，值得一提的是这里的find_limit函数，它实现了从左到右找符合条件的下标，这里的从左到右，就通过“先访问左子节点，左子节点没有结果再访问右子节点”这样一个简单的结构实现。\n改进方法我们注意到，问题本质上是出现在时间复杂度里的这个。它来自于，每一次查询，如果当前节点已经向下分叉，比如node[i].id=-1这种情况出现，那么就必须往下查询其子节点，这就会导致非常恶心的情况。因此，我们需要增加节点的成员，同时增加一个pushup函数来将子节点的信息维护到父节点上，实现更高效的查询\n123456789101112131415161718192021struct nodes {    int ls = 0, rs = 0;    int id = 0; int val = 0;    int id_last = 0;//下面为新增成员    int min_id = 0;     int max_id = 0; };void pushup(int i) {    int ls = node[i].ls;    int rs = node[i].rs;    // 如果孩子存在，就取孩子的 min/max；如果孩子不存在，默认是空地(ID=0)    int l_min = ls ? node[ls].min_id : 0;    int l_max = ls ? node[ls].max_id : 0;    int r_min = rs ? node[rs].min_id : 0;    int r_max = rs ? node[rs].max_id : 0;    // 自己的信息 = 左右孩子的极值    node[i].min_id = min(l_min, r_min);    node[i].max_id = max(l_max, r_max);}\n当然，增加上pushup函数，肯定也需要重构代码中用到的其他函数。\n一些感悟\n此处的pushup函数是对子节点信息的有损压缩。  由于在本题中，只需要判断一个节点包含的区间内，每个点的id是多少，所以只需要判断node[i].min_id==node[i].max_id这个表达式的值即可，这种压缩方式已经足够了。  但是对于其他的题目，有更多构建pushup函数的方法，其核心均在于向上级节点汇总信息；本质上，是对于线段树信息向下分化的逆运算。\n虽然没有完全做出来，我的做法起码处理了m = 1e9这样的东西，比纯粹的暴力法应该还是略胜一筹的。\n\n增加了pushup函数版本的题解代码\n\n\n\n\n\n\n\n\n该版本在acwing上可以通过18/20个样例，不知道为什么剩下两个样例TLE。在Acwing上，由于从至少第九个样例开始n m k就均取到上限，且不给出具体样例，所以。。。就这样吧\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,k,cnt;struct nodes{    int ls=0,rs=0;//左右节点下标    int id=0;int val=0;    int id_last=0;    int min_id=0,max_id=0;};vector&lt;nodes&gt; node;int newnode(){    ++cnt;    nodes a;    node.push_back(a);    return cnt;}void pushdown(int i,int l,int r){    if((node[i].id==-1)||(node[i].id==0&amp;&amp;node[i].val==0&amp;&amp;node[i].id_last==0)) return;    if(!node[i].ls) node[i].ls = newnode();    if(!node[i].rs)  node[i].rs = newnode();    int ls = node[i].ls;int rs = node[i].rs;    if(node[i].id!=-1){    node[ls].id = node[i].id;node[ls].val = node[i].val;node[ls].id_last = node[i].id_last;    node[rs].id = node[i].id;node[rs].val = node[i].val;node[rs].id_last = node[i].id_last;    node[ls].min_id = node[ls].max_id = node[i].id;node[rs].min_id = node[rs].max_id = node[i].id;    }    node[i].id = -1;}void pushup(int i){    int ls = node[i].ls;int rs = node[i].rs;    int l_min = ls ? node[ls].min_id : 0;int l_max = ls ? node[ls].max_id : 0;    int r_min = rs ? node[rs].min_id : 0;int r_max = rs ? node[rs].max_id : 0;    node[i].min_id = min(l_min, r_min);node[i].max_id = max(l_max, r_max);}void update(int i,int l,int r,int id,int ll,int rr,int x){    if(ll&lt;=l&amp;&amp;r&lt;=rr){        node[i].id = id;node[i].val = x;        node[i].min_id = id;node[i].max_id = id;        node[i].id_last = 0;        return;    }    else{                pushdown(i,l,r);        int mid = l+(r-l)/2;        if (ll &lt;= mid){             if (!node[i].ls) node[i].ls = newnode();            int ls = node[i].ls;            update(ls,l,mid,id,ll,rr,x);        }        if(mid&lt;rr){            if (!node[i].rs) node[i].rs = newnode();            int rs = node[i].rs;            update(rs,mid+1,r,id,ll,rr,x);        }        node[i].id = -1;        pushup(i);    }}bool search1_x(int i,int l,int r,int id,int ll,int rr){//查找指定区间上的节点的id是否是指定id    if(i==0) return false;    if(node[i].id!=-1){        return node[i].id==id;    }    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if (node[i].min_id != id || node[i].max_id != id) return false;        return true;    }          int mid = l+(r-l)/2;    if(mid&gt;=ll){        if (!search1_x(node[i].ls, l, mid, id, ll, rr)) return false;    }    if(mid&lt;rr){        if (!search1_x(node[i].rs, mid + 1, r, id, ll, rr)) return false;    }    return true;}void delete_x(int i,int l,int r,int id,int ll,int rr){        if(ll&lt;=l&amp;&amp;r&lt;=rr&amp;&amp;node[i].id!=-1){            node[i].id = 0;            node[i].id_last = id;            node[i].min_id = 0;node[i].max_id = 0;        }        else{            pushdown(i,l,r);            int mid = l+(r-l)/2;            if(mid&gt;=ll){                if(!node[i].ls) node[i].ls = newnode();                int ls=node[i].ls;                delete_x(ls,l,mid,id,ll,rr);            }            if(mid&lt;rr){                if(!node[i].rs) node[i].rs = newnode();                int rs=node[i].rs;                delete_x(rs,mid+1,r,id,ll,rr);            }            node[i].id = -1;            pushup(i);        }}bool search2_x(int i,int l,int r,int id,int ll,int rr){//查找指定区间上的节点的id是否是空的    if(i==0) return false;    if(node[i].id!=-1){        if (node[i].id == 0 &amp;&amp; node[i].id_last == id) return true;        else return false;    }    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if (node[i].max_id != 0) return false;    }    int mid = l+(r-l)/2;    if(mid&gt;=ll){        if (!search2_x(node[i].ls, l, mid, id, ll, rr)) return false;    }    if(mid&lt;rr){        if (!search2_x(node[i].rs, mid + 1, r, id, ll, rr)) return false;    }    return true;}void revive_x(int i,int l,int r,int id,int ll,int rr){        if(ll&lt;=l&amp;&amp;r&lt;=rr&amp;&amp;node[i].id!=-1){            node[i].id=id;            node[i].id_last=0;            node[i].min_id = id;node[i].max_id = id;        }        else{            pushdown(i,l,r);            int mid = l+(r-l)/2;            if(mid&gt;=ll){                if(!node[i].ls) node[i].ls = newnode();                int ls=node[i].ls;                revive_x(ls,l,mid,id,ll,rr);            }            if(mid&lt;rr){                if(!node[i].rs) node[i].rs = newnode();                int rs=node[i].rs;                revive_x(rs,mid+1,r,id,ll,rr);            }            node[i].id = -1;            pushup(i);        }}pair&lt;int,int&gt; search_x(int i,int l,int r,int ll,int rr){    pair&lt;int,int&gt; a;    a.first=0;a.second=0;    if(i==0) return a;    if(node[i].id!=-1){        if (node[i].id == 0) return {0, 0};        else return {node[i].id, node[i].val};    }    int mid = l+(r-l)/2;    if(mid&gt;=ll){        int ls=node[i].ls;        a = search_x(ls,l,mid,ll,rr);    }    if(mid&lt;rr){        int rs=node[i].rs;        a = search_x(rs,mid+1,r,ll,rr);    }    return a;}bool search3_x(int i,int l,int r,int id,int ll,int rr){//查找指定区间上的节点的id是否是指定id或者0    if(i==0) return true;    if(node[i].id!=-1){        if(node[i].id==0||node[i].id==id) return true;        else return false;    }    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if (node[i].max_id == 0) return true;        if (node[i].min_id == id &amp;&amp; node[i].max_id == id) return true;        if (node[i].min_id == node[i].max_id &amp;&amp; node[i].min_id != 0 &amp;&amp; node[i].min_id != id) return false;    }          int mid = l+(r-l)/2;    if(mid&gt;=ll){        if (!search3_x(node[i].ls, l, mid, id, ll, rr)) return false;    }    if(mid&lt;rr){        if (!search3_x(node[i].rs, mid + 1, r, id, ll, rr)) return false;    }       return true;}int find_limit(int i,int l,int r,int id,int ll,int rr){//查找[ll,rr]区间上，第一个不是指定id的下标    if(i==0) return -1;    if(node[i].id!=-1){        if (node[i].id == 0 || node[i].id == id) return -1;        else return max(l, ll);    }    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if (node[i].max_id == 0) return -1;        if (node[i].min_id == id &amp;&amp; node[i].max_id == id) return -1;        if (node[i].min_id == node[i].max_id &amp;&amp; node[i].min_id != 0 &amp;&amp; node[i].min_id != id) return max(l,ll);    }    int mid = l + (r - l) / 2;    int res = -1;    if (ll &lt;= mid) {        res = find_limit(node[i].ls, l, mid, id, ll, rr);        if (res != -1) return res;    }    if (rr &gt; mid) {        return find_limit(node[i].rs, mid + 1, r, id, ll, rr);    }    return -1;}int main(){     cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    nodes dummy;     node.push_back(dummy);    newnode();    while(k--){    int c;cin&gt;&gt;c;    if(c==0){        int id,l,r,x;cin&gt;&gt;id&gt;&gt;l&gt;&gt;r&gt;&gt;x;        if(search3_x(1,1,m,id,l,r)){            update(1,1,m,id,l,r,x);            cout&lt;&lt;r&lt;&lt;endl;        }        else{            int t = find_limit(1,1,m,id,l,r);            if(t&lt;=l&amp;&amp;t!=-1){                cout&lt;&lt;-1&lt;&lt;endl;            }            else{                update(1,1,m,id,l,t-1,x);                cout&lt;&lt;t-1&lt;&lt;endl;            }        }    }    else if(c==1){        int id,l,r;cin&gt;&gt;id&gt;&gt;l&gt;&gt;r;        if(search1_x(1,1,m,id,l,r)){            cout&lt;&lt;\"OK\"&lt;&lt;endl;            delete_x(1,1,m,id,l,r);        }        else cout&lt;&lt;\"FAIL\"&lt;&lt;endl;    }    else if(c==2){        int id,l,r;cin&gt;&gt;id&gt;&gt;l&gt;&gt;r;        if(search2_x(1,1,m,id,l,r)){            cout&lt;&lt;\"OK\"&lt;&lt;endl;            revive_x(1,1,m,id,l,r);        }        else cout&lt;&lt;\"FAIL\"&lt;&lt;endl;    }    else{        int p;cin&gt;&gt;p;        pair&lt;int,int&gt; a = search_x(1,1,m,p,p);        cout&lt;&lt;a.first&lt;&lt;\" \"&lt;&lt;a.second&lt;&lt;endl;    }    }    return 0;}\nAC的解答代码链接：题解来源\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;assert.h&gt;using namespace std;#define FREE 0#define OCCUPIED 1#define ZOMBIE 2#define N_MAX 200005#define MIXED 2000000020#define FULL (-2000000020)struct FILE_BLOCK {    int l, r;    int x;  // value: -1e9~1e9, 2e9: mixed    int id; // id: 1~n(&lt;2e5), 2e9: mixed    int state;  // FREE, OCCUPIED, ZOMBIE, 2e9: mixed};struct OPRT {    OPRT(int t, int i, int ll, int rr, int xx, int pp) : type(t), id(i), l(ll), r(rr), x(xx), p(pp) {}    int type, id, l, r, x, p;};int n, m, k;vector&lt;FILE_BLOCK&gt; fb(N_MAX &lt;&lt; 4);vector&lt;OPRT&gt; oprt;vector&lt;int&gt; coordinates;int discretization() {    coordinates.push_back(0);   // let coordinates begin with 1    sort(coordinates.begin(), coordinates.end());    m = unique(coordinates.begin(), coordinates.end()) - coordinates.begin();   // 1~m    coordinates.resize(m);    for (auto &amp; op : oprt) {        switch (op.type) {            case 0: case 1: case 2:                op.l = lower_bound(coordinates.begin(), coordinates.end(), op.l) - coordinates.begin();                op.r = lower_bound(coordinates.begin(), coordinates.end(), op.r) - coordinates.begin();                break;            case 3: default:                op.p = lower_bound(coordinates.begin(), coordinates.end(), op.p) - coordinates.begin();                break;        }    }    return 0;}void pushup(int curr) {    if (fb[curr&lt;&lt;1].id == fb[curr&lt;&lt;1|1].id) fb[curr].id = fb[curr&lt;&lt;1].id;    else fb[curr].id = MIXED;    if (fb[curr&lt;&lt;1].x == fb[curr&lt;&lt;1|1].x) fb[curr].x = fb[curr&lt;&lt;1].x;    else fb[curr].x = MIXED;    if (fb[curr&lt;&lt;1].state == fb[curr&lt;&lt;1|1].state) fb[curr].state = fb[curr&lt;&lt;1].state;    else fb[curr].state = MIXED;}/* f5 */void build(int curr, int l, int r){    fb[curr].l = l;    fb[curr].r = r;    if (l == r) return;    else {        int mid = l+((r-l)&gt;&gt;1);     // 用减法不用加法，避免爆int        build(curr&lt;&lt;1, l, mid);        build((curr&lt;&lt;1)+1, mid+1, r);        pushup(curr);    }}void pushdown(int curr) {    if (fb[curr].r != fb[curr].l) {        if(fb[curr].id != MIXED) fb[curr &lt;&lt; 1].id = fb[curr &lt;&lt; 1 | 1].id = fb[curr].id;        if(fb[curr].state != MIXED) fb[curr &lt;&lt; 1].state = fb[curr &lt;&lt; 1 | 1].state = fb[curr].state;        if(fb[curr].x != MIXED) fb[curr &lt;&lt; 1].x = fb[curr &lt;&lt; 1 | 1].x = fb[curr].x;    }}/* Interval change *//* update_test: Find the rightmost available to_r */int update_test(int curr, int to_l, int id) {    if (fb[curr].state == FREE || fb[curr].state == ZOMBIE || fb[curr].id == id) return fb[curr].r;    else if (fb[curr].state == OCCUPIED &amp;&amp; fb[curr].id != MIXED) return FULL;   // debug: state = mixed, maybe itself    else {  // state == mixed        int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);        pushdown(curr);        if (to_l &lt;= mid) {            int left_r = update_test(curr&lt;&lt;1, to_l, id);            if (left_r &lt; mid) return left_r;            int right_r = update_test(curr&lt;&lt;1|1, to_l, id);            return right_r == FULL ? left_r : right_r;        }        else {            return update_test(curr&lt;&lt;1|1, to_l, id);        }    }};void update_ic(int curr, int to_l, int to_r, int x, int id) {    if (fb[curr].l == to_l &amp;&amp; fb[curr].r == to_r) { // 刚好覆盖        fb[curr].state = OCCUPIED;        fb[curr].id = id;        fb[curr].x = x;        return;    }    int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);    pushdown(curr);    if (to_l &lt;= mid) update_ic(curr&lt;&lt;1, to_l, min(to_r, mid), x, id);    if (to_r &gt; mid) update_ic(curr&lt;&lt;1|1, max(to_l, mid+1), to_r, x, id);    pushup(curr);};/* Interval deletion */bool deletion_test (int curr, int to_l, int to_r, int id) {    if (fb[curr].l == to_l &amp;&amp; fb[curr].r == to_r) { // 只在完全匹配的时候作判断        if (fb[curr].state == OCCUPIED &amp;&amp; fb[curr].id == id) return true;        else return false;    }    int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);    pushdown(curr);    bool avai = true;    if (to_l &lt;= mid) avai &amp;= deletion_test(curr&lt;&lt;1, to_l, min(to_r, mid), id);    if (to_r &gt; mid) avai &amp;= deletion_test(curr&lt;&lt;1|1, max(to_l, mid+1), to_r, id);    return avai;}void deletion (int curr, int to_l, int to_r, int id) {    if (fb[curr].l == to_l &amp;&amp; fb[curr].r == to_r) {        fb[curr].state = ZOMBIE;        return;    }    int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);    pushdown(curr);    if (to_l &lt;= mid) deletion(curr&lt;&lt;1, to_l, min(to_r, mid), id);    if (to_r &gt; mid) deletion(curr&lt;&lt;1|1, max(to_l, mid+1), to_r, id);    pushup(curr);}/* Interval recovery */bool recover_test (int curr, int to_l, int to_r, int id) {    if (fb[curr].l == to_l &amp;&amp; fb[curr].r == to_r) {        if (fb[curr].state == ZOMBIE &amp;&amp; fb[curr].id == id) return true;        else return false;    }    int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);    pushdown(curr);    bool avai = true;    if (to_l &lt;= mid) avai &amp;= recover_test(curr&lt;&lt;1, to_l, min(to_r, mid), id);    if (to_r &gt; mid) avai &amp;= recover_test(curr&lt;&lt;1|1, max(to_l, mid+1), to_r, id);    return avai;}void recover (int curr, int to_l, int to_r, int id) {    if (fb[curr].l == to_l &amp;&amp; fb[curr].r == to_r) {        fb[curr].state = OCCUPIED;        return;    }    int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);    pushdown(curr);    if (to_l &lt;= mid) recover(curr&lt;&lt;1, to_l, min(to_r, mid), id);    if (to_r &gt; mid) recover(curr&lt;&lt;1|1, max(to_l, mid+1), to_r, id);    pushup(curr);}/* query */int query (int curr, int p) {    if (fb[curr].l == fb[curr].r) return curr;    else if (fb[curr].state != MIXED &amp;&amp; fb[curr].id != MIXED &amp;&amp; fb[curr].x != MIXED) return curr;    else {        int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);        pushdown(curr);        if (p &lt;= mid) return query(curr&lt;&lt;1, p);        else return query(curr&lt;&lt;1|1, p);    }}int main() {    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);    int type=0, id=0, l=0, r=0, x=0, p=0;    for (int i = 0; i &lt; k; i++) {        scanf(\"%d\", &amp;type);        switch (type) {            case 0:                scanf(\"%d%d%d%d\", &amp;id, &amp;l, &amp;r, &amp;x);                oprt.emplace_back(type, id, l, r, x, 0);                break;            case 1:                scanf(\"%d%d%d\", &amp;id, &amp;l, &amp;r);                oprt.emplace_back(type, id, l, r, 0, 0);                break;            case 2:                scanf(\"%d%d%d\", &amp;id, &amp;l, &amp;r);                oprt.emplace_back(type, id, l, r, 0, 0);                break;            case 3:                scanf(\"%d\", &amp;p);                oprt.emplace_back(type, 0, 0, 0, 0, p);                break;            default:                break;        }        if (type == 0 || type == 1 || type == 2) {            coordinates.push_back(l);            coordinates.push_back(r);            if (l != 1) coordinates.push_back(l-1);     // 注意离散化要加入前后的点            if (r != m) coordinates.push_back(r+1);        }        else {            coordinates.push_back(p);        }    }    /* 离散化 */    discretization();    /* 建树 */    build(1, 1, m-1);    int query_index;    for (auto &amp; op : oprt) {        switch (op.type) {            case 0:                op.r = min(op.r, update_test(1, op.l, op.id));                if (op.r != FULL) update_ic(1, op.l, op.r, op.x, op.id);                printf(\"%d\\n\", op.r==FULL?-1:coordinates[op.r]);                break;            case 1:                if (deletion_test(1, op.l, op.r, op.id)) {                    deletion(1, op.l, op.r, op.id);                    printf(\"OK\\n\");                }                else {                    printf(\"FAIL\\n\");                }                break;            case 2:                if (recover_test(1, op.l, op.r, op.id)) {                    recover(1, op.l, op.r, op.id);                    printf(\"OK\\n\");                }                else printf(\"FAIL\\n\");                break;            case 3:                query_index = query(1, op.p);                if (fb[query_index].state != OCCUPIED) printf(\"%d %d\\n\", 0, 0);                else printf(\"%d %d\\n\", fb[query_index].id, fb[query_index].x);                break;            default:                break;        }    }    return 0;}\n一些想法这个解答的做法大概是\n\n对每一次操作的区间边界，用一个结构体oprt存操作的内容和操作的两个区间边界\n把区间边界存到数组coordinates里，同时，更新oprt的成员为coordinates的下标，这通过discretization函数实现\n于是，这样就只需要存大概1e5量级个点。可以直接建一棵完整的线段树来处理。\n\n","slug":"第24次CCFCSP T4：线段树","date":"2026-01-23T16:00:00.000Z","categories_index":"算法,CSP真题","tags_index":"DFS,线段树","author_index":"LHY"},{"id":"497c15de710957392d86e4d03043dcbb","title":"前缀和、子集和以及DP","content":"前缀和记\n\n\n\n那么  就表示了k维的前缀和，需要使用部分和时直接将下标输入计算差值即可。\n\n\n\n\n\n\n\n\n\n本质即空间换时间\n子集和考虑大小为 𝑛 的集合的全体子集上面定义的函数 𝑓 ，现在要求出其子集和函数 𝑔 ，它满足 \n123456for (int i = 0; i &lt; n; ++i) // 遍历每一个维度（即二进制的第 i 位）    for (int mask = 0; mask &lt; (1 &lt;&lt; n); ++mask) // 遍历所有状态        if (mask &amp; (1 &lt;&lt; i)) // 如果当前状态的第 i 位是 1            f[mask] += f[mask ^ (1 &lt;&lt; i)]; // 将“第 i 位是 0”的子集贡献累加过来//包含状态压缩，即用一个二进制下n位的数字存储某个子集。n是S的元素个数。//f[mask] 表示的是 所有属于 mask 子集的状态的初始函数值之和。\n\n\n","slug":"前缀和、子集和以及DP","date":"2026-01-22T16:00:00.000Z","categories_index":"算法","tags_index":"DP,前缀和","author_index":"LHY"},{"id":"2e56aa1cb1c783bcbdadc98ed10245b3","title":"LaTeX语法","content":"对于行内公式，需要用$来包裹；对于跨行公式，需要用$$来包裹\n下标: dp_i  \n小于等于: \\le \n大于等于: \\ge \n不等号: \\neq \n求和: \\sum_{i=1}^{n} \n右箭头: \\rightarrow  类似地也有左箭头\n叉乘: \\times \n点乘: \\cdot \n包含于或等于: \\subseteq \n","slug":"LaTeX语法","date":"2026-01-22T16:00:00.000Z","categories_index":"一些工具","tags_index":"","author_index":"LHY"},{"id":"50b6cecadbf73c890733ae7113a0eab2","title":"路径总和","content":"题目给定一个二叉树，它的每个结点都存放着一个整数值．找出路径和等于给定数值的路径总数．路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）．\n实现只需要两个递归的函数\n123456int count(TreeNode *node, int sum) &#123;  if (node == nullptr) return 0;  return (node-&gt;val == sum) + count(node-&gt;left, sum - node-&gt;val) +         count(node-&gt;right, sum - node-&gt;val);&#125;//count(a,b)表示，从a节点出发，向下求路径节点值的总和，该总和等于b的路径有多少。\n\n123456int pathSum(TreeNode *root, int sum) &#123;  if (root == nullptr) return 0;  return count(root, sum) + pathSum(root-&gt;left, sum) +         pathSum(root-&gt;right, sum);&#125;//pathSum(a,b)表示，从a节点出发，向下求路径节点值的总和，该总和等于b的路径有多少。\n此时只要把根节点、给定的sum丢给pathSum函数就能跑出来答案。直觉上，我感觉pathSum此处的功能有点类似于前缀和。\n\n\n\n\n\n\n\n\n\n非常精巧的递归结构。\n","slug":"路径总和","date":"2026-01-22T16:00:00.000Z","categories_index":"算法","tags_index":"DFS","author_index":"LHY"},{"id":"8577172d587822c13c6c2f341014a5ff","title":"Markdown语法","content":"标题：# title    其中，#的个数即代表为几级标题。\n加粗：**文字**\n列表：- 列表元素 可用缩进表示嵌套列表     1.,2. 即有序数字分隔\n链接：[文字](链接)\n图片：![描述](图片路径)\n\n\n\n\n\n\n\n\n\n如果是网络图片，直接放入其路径即可如果是本地图片，可将图片放入C:\\MyBlog\\source\\images\\文件夹，路径为C:\\MyBlog\\source\\images\\\n引用：&gt; 内容\n代码：```languagetype + code``` or ` code`\n在Front-matter中：    top: 100  &lt;– 自定义一个数字，数字越大越靠前    recommend: true 将会出现在推荐栏    mathjax: true 可以使用数学公式语法\n{% raw %} … {% endraw %}:    是 Hexo 的最高级指令。它告诉编译器：“这中间的所有字符（包括下划线、花括号、引号），你一个都别动，原封不动地交给 MathJax 去处理。”\n","slug":"Markdown语法","date":"2026-01-21T16:00:00.000Z","categories_index":"一些工具","tags_index":"","author_index":"LHY"},{"id":"9014e3c6b93bd70c6ba3cd7677e22fa6","title":"第23次CCFCSP T4学习笔记","content":"题目链接\n\n\n\n\n\n\n\n\nhttps://www.acwing.com/problem/content/4012/\n题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;const int maxn=50;using namespace std;double p[maxn+5];int book[maxn+5];int N,K;double dp[1000][70000];double dfs(int lev,int left,int state){//层数，剩余牌数，01选或者不选的状态    if((lev-(N-left))/K&gt;=left)return lev;    double ans=0;    for(int i=0;i&lt;N;i++){        int temps;        if(book[i]==0){            book[i]=1;            temps=state|(1&lt;&lt;i);            if(dp[lev+1][temps]==0){                dp[lev+1][temps]=dfs(lev+1,left-1,temps);            }            ans+=p[i]*dp[lev+1][temps];            book[i]=0;        }        else{            if(dp[lev+1][state]==0){                dp[lev+1][state]=dfs(lev+1,left,state);            }            ans+=p[i]*dp[lev+1][state];        }    }    return ans;}int main(){    cin&gt;&gt;N&gt;&gt;K;    for(int i=0;i&lt;N;i++){        cin&gt;&gt;p[i];    }    double ans=0;    for(int i=0;i&lt;N;i++){        book[i]=1;        int st=(1&lt;&lt;i);        if(dp[1][st]==0){            dp[1][st]=dfs(1,N-1,st);        }        ans+=p[i]*dfs(1,N-1,st);        book[i]=0;    }    printf(\"%.10f\",ans);    return 0;}原文链接://blog.csdn.net/tongjingqi_/article/details/120831527\n算法技术及其实现\n\n\n\n\n\n\n\n\n状态压缩用一个二进制下n位的数字来存储某个包含n个只有0，1子状态的总状态\n对于一个状态i，cpp i = i | (1&lt;&lt;k) 即第k位设为1cpp i = i &amp; ~(1 &lt;&lt; k) 即第k位设为0\ncpp (i&gt;&gt;(k-1))%2 该表达式表示第k位的状态，用于访问第k位\n经验及思路记录我的代码  123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 65536;int n,k;double p[20],ans;int i;//标记当前状态double dp[80][N+5];//第一个参数表示抽牌的次数，第二个参数表示抽到的牌的状态。p[i][j]表示“抽了j次，抽到了状态为i的牌时，抽完所有牌的期望次数\"bool search(int i,int j){//查询i在第j位上的状态  bool s = (i&gt;&gt;j)%2;  return s;}double dfs(int cnt,int got,int i){//cnt存储当前抽卡的次数，got存储拥有的卡牌数量，i存储拥有的卡牌的状态，    //dfs(i,j,k)表示抽了i次卡，抽到了j张，拥有卡片状态为k时，总共期望需要多少次才能抽完    int coins = cnt - got;//coins存储硬币的数量    double ans = 0;    if(coins&gt;=k*(n-got)) return cnt;    for(int j=0;j&lt;n;j++){        int now = (i|(1&lt;&lt;j));        if(search(i,j)){            if(dp[cnt+1][i]==0) dp[cnt+1][i]=dfs(cnt+1,got,i);            ans += p[j]*dp[cnt+1][i];        }        else{            if(dp[cnt+1][now]==0) dp[cnt+1][now]=dfs(cnt+1,got+1,now);            ans += p[j]*dp[cnt+1][now];        }    }    return ans;}int main(){    cin&gt;&gt; n &gt;&gt; k;    for(int i=0;i&lt;n;i++) cin&gt;&gt;p[i];    double ans = 0;    for(int i=0;i&lt;n;i++){        dp[1][1&lt;&lt;i] = dfs(1,1,1&lt;&lt;i);        ans += p[i]*dp[1][1&lt;&lt;i];    }    cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; ans &lt;&lt; endl;    return 0;}\n改进  原题解中，dfs函数的第二个参数表示未抽到卡片的数量，在我的代码中，dfs函数的第二个参数表示已经抽到卡片的数量。  原题解使用books数组存储书籍在当前的递归链中的被抽取状态；而由于该信息已经存储在dfs的第三个参数里，我选择直接解码第三个参数来获取该信息，避免了不必要的对books数组的维护工作。\n感受  即使看过题解，自己上手写感受还是很不一样的。  我一开始想把dfs函数设置成某个概率，即dfs(i,j,k,…)(此处可能用到不止三个参数)表示抽了“参数1”次牌，抽到了状态为“参数2”的牌的概率。并且，把dp[i][j]设置为抽了i次牌，抽到状态为j的牌的概率。  后来苦思，发现这么做相当于是计算  , 即每抽一次卡就算一次概率,  ，而当前两段代码的思路则是 ，这会导致计算及其麻烦。\n\n\n\n\n\n\n\n\n\n启发\n\n因此，设置dfs函数时要注意运算的方向。\n上面两段代码的思路相当于是\n设置dfs函数为“最终的结果”\n由于这个题目经过有限次递归，总能得到“最终的结果”，所以总能结束\n是从now面向next的\n\n\n而那个错误的思路分支思路相当于是\n设计dfs函数是“从过去的结果得到现在”\n从now面向next\n\n\n总之，DFS技术是“后序依赖”的。\nGemini:“它深入探索直到叶子节点（终点），然后在回溯的过程中，逐层把计算好的结果向上填充。这是一种**“自底向上”**的汇总，每一个状态只会被计算一次（记忆化保证了这一点）。”\n\n\n\n\n\n\n\n\n总结\n\n使用DFS:\n找树\n题目问题能否转换成”一路向下遍历叶子节点，最终抵达某个终点停止，再逐步回溯”\n根据具体性质设置DFS函数\n\n\n\n","slug":"第23次CCFCSP T4学习笔记","date":"2026-01-21T16:00:00.000Z","categories_index":"算法,CSP真题","tags_index":"DP,DFS,状态压缩","author_index":"LHY"},{"id":"170e82ce52ebeae7a2973224969d3bd2","title":"桶：值与下标","content":"“桶”（Bucket）通常不是指某一个特定的标准模板库（STL）容器，而是一种思想或数据组织方式。它的核心逻辑是：利用数组下标来代表数据的值（或值的范围），用数组元素来存储该值的属性（如出现次数、存在性等）。\n\n\n\n\n\n\n\n\n\n用途  1.搜索  类似map的键，将某个值作为键可以快速查询其相关的属性（值），如存在性、出现次数。  2.辅助数据结构  在图论中，这种思想是构建复杂结构的基础。    并查集 (Union-Find)：数组 parent[i] &#x3D; k。        含义：下标 i 代表节点 i，值 k 代表它的父节点是 k。这里完全依赖“节点编号”作为数组下标来快速索引。    邻接表 (存储图的数据结构)：vector adj[N]。        含义：adj[u] 存储的是节点 u 的所有邻居。直接用 u 的编号去访问。\n本质即空间换时间。\n\n\n\n\n\n\n\n\n\n补充并查集：关注一个图中节点的连通性，通常用于解决涉及多个节点间是否连通的问题\n123456789101112131415161718192021222324252627282930313233343536373839vector&lt;int&gt; parent; // 下标=元素，值=父节点vector&lt;int&gt; rank_;  // 按秩合并（秩=树的高度），避免树退化成链表// 初始化：n 为元素总数（元素编号通常从 0 或 1 开始，需匹配题目）void init(int n) &#123;    parent.resize(n);    rank_.resize(n, 1); // 初始每个集合的秩为 1    for (int i = 0; i &lt; n; i++) &#123;        parent[i] = i; // 初始每个元素的父节点是自己（根节点）    &#125;&#125;// 查找：找元素 x 的根节点，带路径压缩（核心优化）int find(int x) &#123;    if (parent[x] != x) &#123;        parent[x] = find(parent[x]); // 递归压缩路径，x 直接指向根    &#125;    return parent[x]; // 返回根节点&#125;此处，无论最终递归多少次，最终返回的都是输入值x的最终的祖宗并且，x的所有的爹，都会被赋值这个祖宗，也就是比它高级的都会被赋值最终用下标代表自己，用parent[x]表示自己的祖宗// 合并：合并 x 和 y 所属的集合，按秩合并（核心优化）void unite(int x, int y) &#123;    int rx = find(x); // 先找 x 的根    int ry = find(y); // 先找 y 的根    if (rx == ry) return; // 已在同一集合，无需合并    // 按秩合并：矮树合并到高树下，减少树的高度    if (rank_[rx] &lt; rank_[ry]) &#123;        parent[rx] = ry;    &#125; else &#123;        parent[ry] = rx;        if (rank_[rx] == rank_[ry]) &#123;            rank_[rx]++; // 秩相等时，合并后秩+1        &#125;    &#125;&#125;\n","slug":"桶：值与下标","date":"2026-01-21T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"LHY"}]