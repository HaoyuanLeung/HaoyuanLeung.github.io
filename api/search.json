[{"id":"2e56aa1cb1c783bcbdadc98ed10245b3","title":"LaTeX语法","content":"对于行内公式，需要用$来包裹；对于跨行公式，需要用$$来包裹\n下标: dp_i  \n小于等于: \\le \n大于等于: \\ge \n不等号: \\neq \n求和: \\sum_{i=1}^{n} \n右箭头: \\rightarrow  类似地也有左箭头\n叉乘: \\times \n点乘: \\cdot \n","slug":"LaTeX语法","date":"2026-01-22T16:00:00.000Z","categories_index":"一些工具","tags_index":"","author_index":"LHY"},{"id":"2bdbc871dc8d9490d9e90b4615d9268f","title":"DFS深度优先搜索技术","content":"DFS是一种算法技术，一般通过DFS函数来实现其功能。\nDFS函数的内容1，终止条件2，标记已访问节点3，访问下一层节点，通常该步骤包含DFS函数的递归，且访问完应该注意节点状态更新4，回溯当前节点\n模板12345678910111213141516171819202122232425262728293031/** * 标准 DFS 函数模板 * @param node     当前访问的节点（或当前状态） * @param G        图的邻接表 * @param visited  访问标记数组 */void dfs(int node, vector&lt;vector&lt;int&gt;&gt;&amp; G, vector&lt;bool&gt;&amp; visited) &#123;        // 1. 终止条件 / 基础处理    // (如果是处理树结构，通常在这里判断 node == nullptr)        // 2. 标记当前节点已访问    visited[node] = true;    cout &lt;&lt; &quot;访问节点: &quot; &lt;&lt; node &lt;&lt; endl;     // 3. 遍历邻居节点（选择列表）    for (int neighbor : G[node]) &#123;                // 4. 合法性检查与递归        if (!visited[neighbor]) &#123;                        // 递归进入下一层            dfs(neighbor, G, visited);                        // 5. 回溯 (Backtracking) - 可选            /* 如果是求所有路径或排列组合，               通常在这里执行 visited[neighbor] = false;             */        &#125;    &#125;&#125;","slug":"DFS深度优先搜索技术","date":"2026-01-21T16:00:00.000Z","categories_index":"算法 - DFS","tags_index":"DFS","author_index":"LHY"},{"id":"9014e3c6b93bd70c6ba3cd7677e22fa6","title":"第23次CCFCSP T4学习笔记","content":"题目链接\n\n\n\n\n\n\n\n\nhttps://www.acwing.com/problem/content/4012/\n题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;const int maxn=50;using namespace std;double p[maxn+5];int book[maxn+5];int N,K;double dp[1000][70000];double dfs(int lev,int left,int state){//层数，剩余牌数，01选或者不选的状态    if((lev-(N-left))/K&gt;=left)return lev;    double ans=0;    for(int i=0;i&lt;N;i++){        int temps;        if(book[i]==0){            book[i]=1;            temps=state|(1&lt;&lt;i);            if(dp[lev+1][temps]==0){                dp[lev+1][temps]=dfs(lev+1,left-1,temps);            }            ans+=p[i]*dp[lev+1][temps];            book[i]=0;        }        else{            if(dp[lev+1][state]==0){                dp[lev+1][state]=dfs(lev+1,left,state);            }            ans+=p[i]*dp[lev+1][state];        }    }    return ans;}int main(){    cin&gt;&gt;N&gt;&gt;K;    for(int i=0;i&lt;N;i++){        cin&gt;&gt;p[i];    }    double ans=0;    for(int i=0;i&lt;N;i++){        book[i]=1;        int st=(1&lt;&lt;i);        if(dp[1][st]==0){            dp[1][st]=dfs(1,N-1,st);        }        ans+=p[i]*dfs(1,N-1,st);        book[i]=0;    }    printf(\"%.10f\",ans);    return 0;}原文链接://blog.csdn.net/tongjingqi_/article/details/120831527\n算法技术及其实现\n\n\n\n\n\n\n\n\n状态压缩用一个二进制下n位的数字来存储某个包含n个只有0，1子状态的总状态\n对于一个状态i，cpp i = i | (1&lt;&lt;k) 即第k位设为1cpp i = i &amp; ~(1 &lt;&lt; k) 即第k位设为0\ncpp (i&gt;&gt;(k-1))%2 该表达式表示第k位的状态，用于访问第k位\n经验及思路记录我的代码  123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 65536;int n,k;double p[20],ans;int i;//标记当前状态double dp[80][N+5];//第一个参数表示抽牌的次数，第二个参数表示抽到的牌的状态。p[i][j]表示“抽了j次，抽到了状态为i的牌时，抽完所有牌的期望次数\"bool search(int i,int j){//查询i在第j位上的状态  bool s = (i&gt;&gt;j)%2;  return s;}double dfs(int cnt,int got,int i){//cnt存储当前抽卡的次数，got存储拥有的卡牌数量，i存储拥有的卡牌的状态，    //dfs(i,j,k)表示抽了i次卡，抽到了j张，拥有卡片状态为k时，总共期望需要多少次才能抽完    int coins = cnt - got;//coins存储硬币的数量    double ans = 0;    if(coins&gt;=k*(n-got)) return cnt;    for(int j=0;j&lt;n;j++){        int now = (i|(1&lt;&lt;j));        if(search(i,j)){            if(dp[cnt+1][i]==0) dp[cnt+1][i]=dfs(cnt+1,got,i);            ans += p[j]*dp[cnt+1][i];        }        else{            if(dp[cnt+1][now]==0) dp[cnt+1][now]=dfs(cnt+1,got+1,now);            ans += p[j]*dp[cnt+1][now];        }    }    return ans;}int main(){    cin&gt;&gt; n &gt;&gt; k;    for(int i=0;i&lt;n;i++) cin&gt;&gt;p[i];    double ans = 0;    for(int i=0;i&lt;n;i++){        dp[1][1&lt;&lt;i] = dfs(1,1,1&lt;&lt;i);        ans += p[i]*dp[1][1&lt;&lt;i];    }    cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; ans &lt;&lt; endl;    return 0;}\n改进  原题解中，dfs函数的第二个参数表示未抽到卡片的数量，在我的代码中，dfs函数的第二个参数表示已经抽到卡片的数量。  原题解使用books数组存储书籍在当前的递归链中的被抽取状态；而由于该信息已经存储在dfs的第三个参数里，我选择直接解码第三个参数来获取该信息，避免了不必要的对books数组的维护工作。\n感受  即使看过题解，自己上手写感受还是很不一样的。  我一开始想把dfs函数设置成某个概率，即dfs(i,j,k,…)(此处可能用到不止三个参数)表示抽了“参数1”次牌，抽到了状态为“参数2”的牌的概率。并且，把dp[i][j]设置为抽了i次牌，抽到状态为j的牌的概率。  后来苦思，发现这么做相当于是计算  , 即每抽一次卡就算一次概率,  ，而当前两段代码的思路则是 ，这会导致计算及其麻烦。\n\n\n\n\n\n\n\n\n\n启发\n\n因此，设置dfs函数时要注意运算的方向。\n上面两段代码的思路相当于是\n设置dfs函数为“最终的结果”\n由于这个题目经过有限次递归，总能得到“最终的结果”，所以总能结束\n是从now面向next的\n\n\n而那个错误的思路分支思路相当于是\n设计dfs函数是“从过去的结果得到现在”\n从now面向next\n\n\n总之，DFS技术是“后序依赖”的。\nGemini:“它深入探索直到叶子节点（终点），然后在回溯的过程中，逐层把计算好的结果向上填充。这是一种**“自底向上”**的汇总，每一个状态只会被计算一次（记忆化保证了这一点）。”\n\n\n\n\n\n\n\n\n总结\n\n使用DFS:\n找树\n题目问题能否转换成”一路向下遍历叶子节点，最终抵达某个终点停止，再逐步回溯”\n根据具体性质设置DFS函数\n\n\n\n","slug":"第23次CCFCSP T4学习笔记","date":"2026-01-21T16:00:00.000Z","categories_index":"CSP真题","tags_index":"DFS,DP,状态压缩","author_index":"LHY"},{"id":"da3b23123e0ba0b7f168c44a617fc023","title":"DP 动态规划技术","content":"包含两个部分：\n\ndp数组，用来存储”某一种状态”\n数组下标的个数n，表示，该状态由n个独立变量确定\n\n\n状态转移方程，用来表示如何从已有的状态推到现在未知的状态\n\n","slug":"DP 动态规划技术","date":"2026-01-21T16:00:00.000Z","categories_index":"算法 - 动态规划","tags_index":"DP","author_index":"LHY"},{"id":"170e82ce52ebeae7a2973224969d3bd2","title":"桶：值与下标","content":"“桶”（Bucket）通常不是指某一个特定的标准模板库（STL）容器，而是一种思想或数据组织方式。它的核心逻辑是：利用数组下标来代表数据的值（或值的范围），用数组元素来存储该值的属性（如出现次数、存在性等）。\n\n\n\n\n\n\n\n\n\n用途  1.搜索  类似map的键，将某个值作为键可以快速查询其相关的属性（值），如存在性、出现次数。  2.辅助数据结构  在图论中，这种思想是构建复杂结构的基础。    并查集 (Union-Find)：数组 parent[i] &#x3D; k。        含义：下标 i 代表节点 i，值 k 代表它的父节点是 k。这里完全依赖“节点编号”作为数组下标来快速索引。    邻接表 (存储图的数据结构)：vector adj[N]。        含义：adj[u] 存储的是节点 u 的所有邻居。直接用 u 的编号去访问。\n本质即空间换时间。\n\n\n\n\n\n\n\n\n\n补充并查集：关注一个图中节点的连通性，通常用于解决涉及多个节点间是否连通的问题\n123456789101112131415161718192021222324252627282930313233343536373839vector&lt;int&gt; parent; // 下标=元素，值=父节点vector&lt;int&gt; rank_;  // 按秩合并（秩=树的高度），避免树退化成链表// 初始化：n 为元素总数（元素编号通常从 0 或 1 开始，需匹配题目）void init(int n) &#123;    parent.resize(n);    rank_.resize(n, 1); // 初始每个集合的秩为 1    for (int i = 0; i &lt; n; i++) &#123;        parent[i] = i; // 初始每个元素的父节点是自己（根节点）    &#125;&#125;// 查找：找元素 x 的根节点，带路径压缩（核心优化）int find(int x) &#123;    if (parent[x] != x) &#123;        parent[x] = find(parent[x]); // 递归压缩路径，x 直接指向根    &#125;    return parent[x]; // 返回根节点&#125;此处，无论最终递归多少次，最终返回的都是输入值x的最终的祖宗并且，x的所有的爹，都会被赋值这个祖宗，也就是比它高级的都会被赋值最终用下标代表自己，用parent[x]表示自己的祖宗// 合并：合并 x 和 y 所属的集合，按秩合并（核心优化）void unite(int x, int y) &#123;    int rx = find(x); // 先找 x 的根    int ry = find(y); // 先找 y 的根    if (rx == ry) return; // 已在同一集合，无需合并    // 按秩合并：矮树合并到高树下，减少树的高度    if (rank_[rx] &lt; rank_[ry]) &#123;        parent[rx] = ry;    &#125; else &#123;        parent[ry] = rx;        if (rank_[rx] == rank_[ry]) &#123;            rank_[rx]++; // 秩相等时，合并后秩+1        &#125;    &#125;&#125;\n","slug":"桶：值与下标","date":"2026-01-21T16:00:00.000Z","categories_index":"算法","tags_index":"","author_index":"LHY"},{"id":"8577172d587822c13c6c2f341014a5ff","title":"Markdown语法","content":"标题：# title    其中，#的个数即代表为几级标题。\n加粗：**文字**\n列表：- 列表元素 可用缩进表示嵌套列表     1.,2. 即有序数字分隔\n链接：[文字](链接)\n图片：![描述](图片路径)\n\n\n\n\n\n\n\n\n\n如果是网络图片，直接放入其路径即可如果是本地图片，可将图片放入C:\\MyBlog\\source\\images\\文件夹，路径为C:\\MyBlog\\source\\images\\\n引用：&gt; 内容\n代码：```languagetype + code``` or ` code`\n在Front-matter中：    top: 100  &lt;– 自定义一个数字，数字越大越靠前    recommend: true 将会出现在推荐栏\n","slug":"Markdown语法","date":"2026-01-21T16:00:00.000Z","categories_index":"一些工具","tags_index":"","author_index":"LHY"}]