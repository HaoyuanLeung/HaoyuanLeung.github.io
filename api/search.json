[{"id":"a448dfd8ebb4408d1633f0dff8411f1c","title":"çº¿æ®µæ ‘","content":"çº¿æ®µæ ‘åˆæ­¥å»ºæ ‘å‡½æ•°1234567891011121314151617181920const int maxn = (int)1e5;struct node &#123;    int l, r, v;&#125; a[maxn &lt;&lt; 2];//å› ä¸ºçº¿æ®µæ ‘çš„é«˜åº¦æ˜¯log_2 n,æ€»å ç”¨éœ€è¦æœ€å¤š4nï¼Œè¿™é‡Œå°½é‡å¾€å¤§äº†å¼€ã€‚int num[maxn];void build(int id, int l, int r) &#123;    a[id].l = l;    a[id].r = r;    if (l == r) &#123;        a[id].v = num[l];        return;    &#125;    int mid = l + r &gt;&gt; 1;    build(id &lt;&lt; 1, l, mid);    build(id &lt;&lt; 1 | 1, mid + 1, r);//åˆ†åˆ«ç­‰ä»·äº *2 ä¸ *2+1    a[id].v = a[id &lt;&lt; 1].v + a[id &lt;&lt; 1 | 1].v;    return;&#125;\nä¿®æ”¹æŸäº›èŠ‚ç‚¹ä¸Šçš„å€¼æ–¹æ¡ˆä¸€ï¼šç»™æŸä¸ªèŠ‚ç‚¹èµ‹å€¼\n12345678910111213141516171819202122232425262728//èµ‹å€¼å‡½æ•°void opt_1(int id, int k, int v) &#123;//idæ˜¯ä»ç¬¬idä¸ªèŠ‚ç‚¹å‡ºå‘ï¼Œkæ˜¯æƒ³è¦ä¿®æ”¹çš„ç‚¹çš„ä½ç½®ï¼ˆåé¢é€’å½’çš„éƒ¨åˆ†å®é™…ä¸Šæ˜¯äºŒåˆ†ï¼‰ï¼Œvæ˜¯å¸Œæœ›ç»™è¿™ä¸ªç‚¹èµ‹çš„å€¼    int l = a[id].l;    int r = a[id].r;    if (l == r) &#123;        a[id].v = v;        return;    &#125;    int mid = l + r &gt;&gt; 1;    if (mid &lt; k) opt_1(id &lt;&lt; 1 | 1, k, v);    else opt_1(id &lt;&lt; 1, k, v);    a[id].v = a[id &lt;&lt; 1].v + a[id &lt;&lt; 1 | 1].v;    return;&#125;int opt_2(int id, int tgtl, int tgtr) &#123;//è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œidä¸€èˆ¬å¾—æ˜¯æ ¹èŠ‚ç‚¹çš„ä¸‹æ ‡ï¼ˆé¿å…ä¸€å¼€å§‹èŠ‚ç‚¹çš„åŒºé—´å°±è¢«åŒ…è£¹ï¼‰    //åé¢ä¸¤ä¸ªå‚æ•°åˆ†åˆ«æ˜¯åŒºé—´çš„å·¦å³è¾¹ç•Œ    //è¿”å›å€¼ä¸ºä¸€ä¸ªä»tgtlåˆ°tgtrçš„éƒ¨åˆ†å’Œ    int l = a[id].l;    int r = a[id].r;    if (tgtl &lt;= l &amp;&amp; r &lt;= tgtr) return a[id].v;    int mid = l + r &gt;&gt; 1;    if (mid &gt;= tgtr) return opt_2(id &lt;&lt; 1, tgtl, tgtr);    else if (mid &lt; tgtl) return opt_2(id &lt;&lt; 1 | 1, tgtl, tgtr);    return opt_2(id &lt;&lt; 1, tgtl, tgtr) + opt_2(id &lt;&lt; 1 | 1, tgtl, tgtr);&#125;//ä¸­é—´çš„ifå’Œelse ifæ˜¯ä¸€ä¸ªäºŒåˆ†ï¼Œå³åˆ¤æ–­æ˜¯å¾€å·¦èµ°è¿˜æ˜¯å¾€å³èµ°//æœ€å…³é”®çš„æ˜¯æœ€åä¸€ä¸ªreturnã€‚é€šè¿‡è¿™ä¸€è¡Œå¯ä»¥æŠŠé›¶ç¢çš„å­åŒºé—´æ‹¼å‡‘æˆéœ€è¦çš„åŒºé—´\n\næ–¹æ¡ˆäºŒï¼šç»™åŒºé—´èµ‹å€¼\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263    //1ï¼Œé¦–å…ˆç»™æ¯ä¸ªèŠ‚ç‚¹å¢åŠ ä¸€ä¸ªæˆå‘˜    struct node &#123;        int l, r;        long long v;   // åŒºé—´å’Œ        long long tag; // æ ‡è®°ï¼šå­˜å‚¨å…¶æ¯ä¸ªä¸‹å±èŠ‚ç‚¹éœ€è¦åŠ ä¸Šçš„å€¼    &#125; a[maxn &lt;&lt; 2];    //2ï¼Œåˆ†å‘å‡½æ•°ï¼šè®¿é—®å­èŠ‚ç‚¹å‰ï¼ŒæŠŠçˆ¶èŠ‚ç‚¹çš„å€ºï¼ˆtagï¼‰åˆ†å‘ç»™ä¸¤ä¸ªå­©å­ã€‚    void push_down(int id) &#123;        // å¦‚æœå½“å‰èŠ‚ç‚¹æœ‰æ ‡è®°ï¼ˆtagä¸ä¸º0ï¼‰        if (a[id].tag != 0) &#123;            int left = id &lt;&lt; 1;      // å·¦å­©å­ä¸‹æ ‡                int right = id &lt;&lt; 1 | 1; // å³å­©å­ä¸‹æ ‡            long long t = a[id].tag; // å–å‡ºæ ‡è®°å€¼            // 1. æ›´æ–°å·¦å­©å­çš„æ•°å€¼å’Œæ ‡è®°            // å·¦å­©å­çš„æ–°å€¼ = æ—§å€¼ + å¢åŠ é‡ * åŒºé—´é•¿åº¦            a[left].v += t * (a[left].r - a[left].l + 1);            a[left].tag += t; // ç´¯åŠ æ ‡è®°            // 2. æ›´æ–°å³å­©å­çš„æ•°å€¼å’Œæ ‡è®°            a[right].v += t * (a[right].r - a[right].l + 1);            a[right].tag += t;            // 3. æ¸…ç©ºå½“å‰èŠ‚ç‚¹çš„æ ‡è®°ï¼ˆå€ºå·²è¿˜æ¸…ï¼‰            a[id].tag = 0;            &#125;    &#125;    //3ï¼Œä¿®æ”¹åŒºé—´å€¼    // id:å½“å‰èŠ‚ç‚¹, [l,r]:ä¿®æ”¹çš„ç›®æ ‡åŒºé—´, val:è¦å¢åŠ çš„å€¼    void update(int id, int l, int r, int val) &#123;        int L = a[id].l;        int R = a[id].r;        // æƒ…å†µ1ï¼šå½“å‰èŠ‚ç‚¹åŒºé—´å®Œå…¨è¢«ç›®æ ‡åŒºé—´åŒ…å«        // ç›´æ¥ä¿®æ”¹å½“å‰èŠ‚ç‚¹ï¼Œæ‰“ä¸Šæ ‡è®°ï¼Œä¸å†å‘ä¸‹        if (l &lt;= L &amp;&amp; R &lt;= r) &#123;            a[id].v += (long long)val * (R - L + 1); // æ›´æ–°å½“å‰èŠ‚ç‚¹çš„æ€»å’Œ            a[id].tag += val;                        // æ‰“ä¸Šæ ‡è®°        return;        &#125;        // æƒ…å†µ2ï¼šä¸å®Œå…¨åŒ…å«ï¼Œéœ€è¦å‘ä¸‹é€’å½’        // ã€å…³é”®ã€‘ï¼šåœ¨åˆ†å‰ä¹‹å‰ï¼Œå¿…é¡»å…ˆæŠŠèº«ä¸Šçš„æ ‡è®°æ¨ä¸‹å»ï¼        push_down(id);        int mid = (L + R) &gt;&gt; 1;        if (l &lt;= mid) update(id &lt;&lt; 1, l, r, val);      // æ¶‰åŠå·¦è¾¹å°±å»å·¦è¾¹        if (r &gt; mid)  update(id &lt;&lt; 1 | 1, l, r, val);  // æ¶‰åŠå³è¾¹å°±å»å³è¾¹        // å›æº¯ï¼šæ›´æ–°çˆ¶èŠ‚ç‚¹çš„å€¼ (Push Up)        a[id].v = a[id &lt;&lt; 1].v + a[id &lt;&lt; 1 | 1].v;    &#125;    //4ï¼ŒåŒºé—´æŸ¥è¯¢        long long query(int id, int l, int r) &#123;//è¿™ä¸ªå‡½æ•°çš„åŠŸèƒ½æ˜¯ï¼Œä»ä¸‹æ ‡ä¸ºidçš„ç»“ç‚¹å‡ºå‘ï¼ŒæŸ¥è¯¢åŒºé—´[l,r]çš„æ€»å’Œ        int L = a[id].l;        int R = a[id].r;        if (l &lt;= L &amp;&amp; R &lt;= r) &#123;            return a[id].v;        &#125;        // ã€å…³é”®ã€‘ï¼šæŸ¥è¯¢ä¹‹å‰ä¹Ÿè¦æ¨æ ‡è®°        push_down(id);        int mid = (L + R) &gt;&gt; 1;        long long res = 0;        if (l &lt;= mid) res += query(id &lt;&lt; 1, l, r);//è¿™ä¸ªåœ°æ–¹é€šè¿‡ç´¯åŠ å®ç°åŒºé—´çš„åˆ†å‰²        if (r &gt; mid)  res += query(id &lt;&lt; 1 | 1, l, r);        return res;&#125;\n\nåŠ¨æ€å¼€ç‚¹æ•°æ®ç»“æ„è®¾è®¡123456789101112131415161718//å…¨å±€è®¡æ•°å™¨int cnt = 0; // ä»£è¡¨å½“å‰ç”¨åˆ°äº†ç¬¬å‡ ä¸ªèŠ‚ç‚¹int root;struct node&#123;    int ls,rs;//å·¦å³å­èŠ‚ç‚¹çš„ä¸‹æ ‡    long long val;//èŠ‚ç‚¹éœ€è¦å­˜å‚¨çš„å±æ€§ï¼Œå¯ä»¥å¼€å¤šå‡ ä¸ªä¹Ÿæ²¡å…³ç³»ã€‚    long long tag;//æ ‡è®°&#125;int new_node()&#123;//æŠŠç”Ÿæˆæ–°èŠ‚ç‚¹çš„éƒ¨åˆ†ç‹¬ç«‹å‡ºæ¥ï¼Œè°ƒç”¨ä¸€æ¬¡è¿™ä¸ªå‡½æ•°å°±cnt++ï¼Œé˜²æ­¢æ··æ·†    ++cnt;    tree[cnt].ls = 0;    tree[cnt].rs = 0;    tree[cnt].val = 0;    tree[cnt].tag = 0;    return cnt;&#125;\nåŸºç¡€åŠŸèƒ½å‡½æ•°12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879801ï¼Œæ›´æ–°çˆ¶èŠ‚ç‚¹çš„å€¼//ä»ä¸‹æ ‡ä¸ºpçš„èŠ‚ç‚¹å‡ºå‘éå†å®ƒçš„åä»£ï¼Œä»¥è¾¾åˆ°æ›´æ–°è‡ªå·±çš„ç›®çš„void push_up(int p) &#123;    // æ³¨æ„ï¼šå¦‚æœå­©å­ä¸å­˜åœ¨(æ˜¯0)ï¼Œé‚£ä¹ˆé‚£è¾¹çš„å€¼å°±æ˜¯0    // tree[0] å…¨å±€é»˜è®¤ä¸º0ï¼Œæ‰€ä»¥ç›´æ¥åŠ ä¹Ÿæ²¡é—®é¢˜ï¼Œä½†å†™æ¸…æ¥šæ›´å¥½    long long left_val = (tree[p].ls ? tree[tree[p].ls].val : 0);    long long right_val = (tree[p].rs ? tree[tree[p].rs].val : 0);    tree[p].val = left_val + right_val;&#125;2ï¼Œtagså‘ä¸‹ä¼ é€’//å¯¹äºtagsçš„ä¼ é€’ï¼Œæ™®é€šçº¿æ®µæ ‘ç”±äºä¸‹æ ‡éƒ½æ˜¯å›ºå®šçš„æ¯”è¾ƒæ–¹ä¾¿ï¼Œå¯¹äºåŠ¨æ€å¼€ç‚¹çš„çº¿æ®µæ ‘éœ€è¦ç‰¹æ®Šçš„å¤„ç†æ–¹æ³•void push_down(int p, int l, int r) &#123;    if (tree[p].tag == 0) return; // æ²¡æœ‰æ ‡è®°ï¼Œä¸ç”¨ä¸‹ä¼     int mid = l + (r - l) / 2;    long long t = tree[p].tag;    // --- å·¦è¾¹ ---    if (!tree[p].ls) tree[p].ls = new_node(); // 1. æ²¡äº†å°±å»º    int ls = tree[p].ls;    tree[ls].val += t * (mid - l + 1);        // 2. æ›´æ–°æ•°å€¼    tree[ls].tag += t;                        // 3. ä¼ é€’æ ‡è®°    // --- å³è¾¹ ---    if (!tree[p].rs) tree[p].rs = new_node(); // 1. æ²¡äº†å°±å»º    int rs = tree[p].rs;    tree[rs].val += t * (r - mid);            // 2. æ›´æ–°æ•°å€¼    tree[rs].tag += t;                        // 3. ä¼ é€’æ ‡è®°    // --- æ¸…ç©ºçˆ¶èŠ‚ç‚¹ ---    tree[p].tag = 0;&#125;3ï¼ŒåŒºé—´ä¿®æ”¹//åŒºé—´ä¿®æ”¹ï¼šå°†åŒºé—´ [ql, qr] å†…æ‰€æœ‰æ•°éƒ½ + kvoid update(int &amp;p, int l, int r, int ql, int qr, int k) &#123;    // å¦‚æœ p è¿˜æ˜¯ 0ï¼ˆè¯´æ˜è¿™é‡Œä»æ¥æ²¡è¢«è®¿é—®è¿‡ï¼‰ï¼Œå…ˆå»ºä¸ªå·    if (!p) p = new_node();    // 1. å®Œå…¨åŒ…å«ï¼šç›´æ¥æ”¹è‡ªå·±ï¼Œæ‰“æ¡å­ï¼Œèµ°äºº    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;        tree[p].val += (long long)k * (r - l + 1);        tree[p].tag += k;        return;    &#125;    // 2. ä¸å®Œå…¨åŒ…å«ï¼šå…ˆä¸‹æ”¾æ ‡è®°ï¼Œå†åˆ†å¤´è¡ŒåŠ¨    push_down(p, l, r);    int mid = l + (r - l) / 2;    if (ql &lt;= mid) update(tree[p].ls, l, mid, ql, qr, k);    if (qr &gt; mid)  update(tree[p].rs, mid + 1, r, ql, qr, k);    // 3. å­©å­å˜äº†ï¼Œé‡æ–°ç®—è‡ªå·±çš„æ€»å¸    push_up(p);&#125;4ï¼Œéƒ¨åˆ†å’ŒæŸ¥è¯¢//åŒºé—´æŸ¥è¯¢ï¼šæŸ¥è¯¢[ql, qr]çš„å’Œlong long query(int p, int l, int r, int ql, int qr) &#123;    // å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œæˆ–è€…åŒºé—´æ²¡äº¤é›†ï¼Œé‚£å°±æ˜¯ 0    if (!p) return 0;    // 1. å®Œå…¨åŒ…å«ï¼šç›´æ¥è¿”å›    if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123;        return tree[p].val;    &#125;    // 2. è¦å¾€ä¸‹æŸ¥ï¼Œè®°å¾—å…ˆæ¨æ ‡è®°ï¼å¦åˆ™å­©å­çš„æ•°æ®æ˜¯æ—§çš„    push_down(p, l, r);         int mid = l + (r - l) / 2;    long long res = 0;    if (ql &lt;= mid) res += query(tree[p].ls, l, mid, ql, qr);    if (qr &gt; mid)  res += query(tree[p].rs, mid + 1, r, ql, qr);    return res;&#125;","slug":"çº¿æ®µæ ‘åŠæ‹“å±•","date":"2026-01-24T16:00:00.000Z","categories_index":"æ¿å­,ç®—æ³•","tags_index":"çº¿æ®µæ ‘,DFS","author_index":"LHY"},{"id":"855fd15caf769c47ad1d3f666d603bb2","title":"æ´›è°·P10497åšé¢˜è®°å½•","content":"é¢˜ç›®é“¾æ¥https://www.luogu.com.cn/problem/P10497\né¢˜è§£æš´åŠ›åšæ³•ä¸éš¾å‘ç°ï¼Œä¸å¦¨è®¾ç¬¬ä¸€ä¸ªè¾“å…¥çš„åºæ•°æ˜¯0ã€‚é‚£ä¹ˆæœ€åä¸€ä¸ªåºæ•°è¡¨ç¤ºçš„æ˜¯ï¼šæœ€åä¸€å¤´ç‰›çš„ç¼–å·-1ã€‚ä»æœ€åä¸€å¤´ç‰›é€†å‘é€’æ¨ï¼Œä¸»è¦åŒ…å«ä¸¤ä¸ªæŸ¥è¯¢ï¼Œ1ï¼Œå·²ç»ç®—è¿‡ç¼–å·çš„ç‰›é‡Œï¼Œæœ‰æ²¡æœ‰æ¯”æˆ‘è¿™å¤´ç‰›è¦å°çš„ï¼Ÿæœ‰çš„è¯+1ï¼Œå¯ä»¥å¾—åˆ°ä¸€ä¸ªå åŠ çš„delta2ï¼Œåºæ•°+1+å‰é¢å åŠ çš„deltaä¹‹åï¼Œå¾—åˆ°çš„å€¼æ˜¯å¦åœ¨å·²ç»ç®—å‡ºæ¥ç¼–å·çš„ç‰›é‡Œï¼Ÿæ˜¯çš„è¯ï¼Œå†+1è·³è¿‡è¢«å ç”¨çš„ç¼–å·ã€‚\næœ¬é¢˜çš„æ‰€æœ‰åšæ³•éƒ½åŸºäºä»¥ä¸Šæ€æƒ³ï¼Œä¼˜åŒ–åˆ™é’ˆå¯¹ä¸¤ç§æŸ¥è¯¢\n12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[10001],s,st[10001];bool vis[10001];int main()&#123;  cin&gt;&gt;n;  for(int i = 2;i &lt;= n;i++) cin&gt;&gt;a[i];  for(int i = n;i &gt;= 1;i--)  &#123;    s = 0;    for(int j = 1;j &lt;= n;j++)      if(vis[j] == 0)      &#123;        s++;        if(s == a[i] + 1)        &#123;          vis[j] = 1;          st[i] = j;        &#125;      &#125;  &#125;  for(int i = 1;i &lt;= n;i++) cout&lt;&lt;st[i]&lt;&lt;&#x27;\\n&#x27;;  return 0;&#125;\nçº¿æ®µæ ‘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int MAXN = 100005;int sum[MAXN * 4]; // çº¿æ®µæ ‘æ•°ç»„ï¼Œè®°å¾—å¼€ 4 å€int n;int a[MAXN], ans[MAXN];// å»ºæ ‘ï¼šåˆå§‹åŒ–æ‰€æœ‰å¶å­èŠ‚ç‚¹ä¸º 1void build(int p, int l, int r) &#123;    if (l == r) &#123;        sum[p] = 1; // åˆå§‹æ—¶ï¼Œæ¯ä¸ªæ•°å­—éƒ½å­˜åœ¨        return;    &#125;    int mid = (l + r) / 2;    build(p * 2, l, mid);    build(p * 2 + 1, mid + 1, r);    sum[p] = sum[p * 2] + sum[p * 2 + 1]; // push up&#125;// æ ¸å¿ƒï¼šæŸ¥æ‰¾ç¬¬ k å°ï¼Œå¹¶å°†å…¶åˆ æ‰ï¼ˆå‡1ï¼‰// è¿”å›å€¼æ˜¯æ‰¾åˆ°çš„é‚£ä¸ªæ•°å­—int query_and_delete(int p, int l, int r, int k) &#123;//åŒæ ·åœ°ï¼Œå‚æ•°æ„å‘³åˆ†åˆ«æ˜¯ä»ç¬¬pä¸ªèŠ‚ç‚¹å‡ºå‘ï¼ŒæŸ¥è¯¢åŒºé—´[l,r]ä¹‹é—´ç¬¬kå°çš„æ•°å­—ã€‚    sum[p]--; // ã€æŠ€å·§ã€‘å› ä¸ºæˆ‘ä»¬è¦åˆ æ‰è¿™ä¸ªæ•°ï¼Œæ‰€ä»¥åœ¨è·¯å¾„ä¸Šç›´æ¥å‡ 1 å³å¯    if (l == r) &#123;        return l; // æ‰¾åˆ°äº†ï¼Œè¿”å›å…·ä½“çš„æ•°å€¼    &#125;    int mid = (l + r) / 2;    int left_cnt = sum[p * 2]; // å·¦å­æ ‘é‡Œè¿˜å‰©å¤šå°‘ä¸ªæ•°    if (k &lt;= left_cnt) &#123;        // åœ¨å·¦è¾¹        return query_and_delete(p * 2, l, mid, k);    &#125; else &#123;        // åœ¨å³è¾¹ï¼Œæ³¨æ„è¦å‡å»å·¦è¾¹å·²æœ‰çš„æ•°é‡        return query_and_delete(p * 2 + 1, mid + 1, r, k - left_cnt);    &#125;&#125;int main() &#123;    ios::sync_with_stdio(false);    cin &gt;&gt; n;    // å»ºæ ‘    build(1, 1, n);    a[1] = 0;    for (int i = 2; i &lt;= n; i++) cin &gt;&gt; a[i];    // å€’åºå¤„ç†    for (int i = n; i &gt;= 1; i--) &#123;        int k = a[i] + 1; // æ‰¾å‰©ä½™æ•°å­—é‡Œçš„ç¬¬ k å°        ans[i] = query_and_delete(1, 1, n, k);    &#125;    for (int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;    return 0;&#125;\nè¿™é‡Œï¼Œsumæ•°ç»„åªæ˜¯ç”¨æ¥æ ‡è®°æŸä¸ªæ•°æ˜¯å¦å·²ç»è¢«å–å‡ºï¼Œä¹Ÿå°±æ˜¯é’ˆå¯¹æŸ¥è¯¢äºŒã€‚é’ˆå¯¹æŸ¥è¯¢ä¸€ï¼Œåˆ™æ˜¯é€šè¿‡query_and_deleteå‡½æ•°å®ç°\næ ‘çŠ¶æ•°ç»„é¦–å…ˆè½¬æ¢æˆå‰ç¼€å’Œé—®é¢˜å’Œå‰é¢çš„ä¸€æ ·ï¼Œå…ˆæŠŠ æ ‡è®°æŸä¸ªæ•°æ˜¯å¦å·²ç»å­˜åœ¨çš„æ•°ç»„tree[MAXN]è®¾å®šå¥½ï¼ˆå‡ä¸º0ä¸1ï¼‰ï¼Œç„¶åè½¬ä¸ºæ ‘çŠ¶æ•°ç»„é‚£ä¹ˆè·Ÿæœ‰kä¸ªæ•°æ¯”å®ƒå°æœ‰å…³çš„æŸ¥è¯¢ï¼Œå°±å˜æˆäº†ä¸€ä¸ªæ±‚å‰ç¼€å’Œçš„é—®é¢˜ï¼Œåªè¦æ‰¾åˆ° å‰ç¼€å’Œç­‰äºk+1 çš„ä¸‹æ ‡ï¼Œå³å¯\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100005; // æ ¹æ®é¢˜ç›®è¦æ±‚è°ƒæ•´int tree[MAXN]; // BITæ•°ç»„int n;int a[MAXN];    // å­˜è¾“å…¥çš„â€œå‰é¢æœ‰å¤šå°‘ä¸ªæ¯”å®ƒå°â€int ans[MAXN];  // å­˜ç»“æœ// lowbit æ“ä½œint lowbit(int x) &#123; return x &amp; -x; &#125;// å•ç‚¹ä¿®æ”¹ï¼šè®©ä½ç½® x çš„å­˜æ´»çŠ¶æ€ +v (1æˆ–-1)void add(int x, int v) &#123;    for (; x &lt;= n; x += lowbit(x)) tree[x] += v;&#125;// ã€æ ¸å¿ƒã€‘å€å¢æŸ¥æ‰¾ï¼šæ‰¾åˆ°å½“å‰ç¬¬ k å°çš„å¯ç”¨æ•°å­—// åŸç†ï¼šåˆ©ç”¨äºŒè¿›åˆ¶æ‹†åˆ†ï¼Œä»é«˜ä½å‘ä½ä½å°è¯•ç´¯åŠ int find_kth(int k) &#123;    int pos = 0;       // å½“å‰ç¡®å®šçš„ä½ç½®    int total = 0;     // å½“å‰ä½ç½®çš„å‰ç¼€å’Œ    // å‡è®¾ N &lt;= 100000ï¼Œ2^17 &gt; 100000ï¼Œæ‰€ä»¥ä» 17 å¼€å§‹å‘ä¸‹æšä¸¾    // é€šç”¨å†™æ³•æ˜¯ for (int i = 1 &lt;&lt; (int)log2(n); i &gt; 0; i &gt;&gt;= 1)    for (int i = 1 &lt;&lt; 17; i &gt; 0; i &gt;&gt;= 1) &#123;        // å¦‚æœè·³è·ƒåçš„ä½ç½®åœ¨èŒƒå›´å†…ï¼Œä¸”åŠ ä¸Šè¿™ä¸€æ®µåçš„æ€»å’Œä»ç„¶ &lt; k        if (pos + i &lt;= n &amp;&amp; total + tree[pos + i] &lt; k) &#123;            pos += i;            // ç¡®å®šè¿™ä¸€ä½æ˜¯1ï¼Œä½ç½®å‘å‰æ¨è¿›            total += tree[pos];  // æ›´æ–°å·²ç´¯è®¡çš„æ•°é‡        &#125;    &#125;    // å¾ªç¯ç»“æŸæ—¶ï¼Œpos æ˜¯æ»¡è¶³ sum &lt; k çš„æœ€å¤§ä½ç½®    // æ‰€ä»¥ pos + 1 å°±æ˜¯æ»¡è¶³ sum &gt;= k çš„ç¬¬ä¸€ä¸ªä½ç½®ï¼ˆå³ç¬¬ k å°ï¼‰    return pos + 1;&#125;int main() &#123;    ios::sync_with_stdio(false);    cin &gt;&gt; n;    // 1. åˆå§‹åŒ– BITï¼šæ‰€æœ‰æ•°å­— 1~n éƒ½åœ¨ï¼Œåˆå§‹å€¼ä¸º 1    // ä¹Ÿå¯ä»¥ç›´æ¥ç”¨ O(N) å»ºæ ‘ï¼Œè¿™é‡Œç®€å•ç”¨å¾ªç¯ add    for (int i = 1; i &lt;= n; i++) add(i, 1);    // 2. è¯»å–è¾“å…¥ï¼ˆé¢˜ç›®é€šå¸¸æ˜¯ä»ç¬¬2ä¸ªå¼€å§‹ç»™ï¼Œè¿™é‡Œå‡è®¾å·²å¤„ç†å¥½ä¸‹æ ‡ï¼‰    // æ³¨æ„ï¼šPOJ2182ç¬¬ä¸€å¤´ç‰›é»˜è®¤æ˜¯0ï¼Œè¾“å…¥ä¸€èˆ¬ç»™ 2~N è¡Œ    a[1] = 0;     for (int i = 2; i &lt;= n; i++) cin &gt;&gt; a[i];    // 3. å€’åºå¤„ç†    for (int i = n; i &gt;= 1; i--) &#123;        // a[i] è¡¨ç¤ºå‰é¢æœ‰ a[i] ä¸ªæ¯”å®ƒå°        // æ‰€ä»¥å®ƒæ˜¯å½“å‰å‰©ä½™é›†åˆä¸­çš„ç¬¬ a[i] + 1 å°        int k = a[i] + 1;        // æŸ¥æ‰¾ç¬¬ k å°        int val = find_kth(k);        ans[i] = val;        // åˆ é™¤è¿™ä¸ªæ•°ï¼ˆæƒå€¼ -1ï¼‰        add(val, -1);    &#125;    // 4. è¾“å‡º    for (int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;    return 0;&#125;\né€šè¿‡find_kthå‡½æ•°å®ç°äº†æŸ¥è¯¢ä¸€é€šè¿‡å®æ—¶æ›´æ–°ï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨addå‡½æ•°å®ç°æŸ¥è¯¢äºŒ\n","slug":"æ´›è°·P10497 ä»åºæ•°å‡ºå‘","date":"2026-01-24T16:00:00.000Z","categories_index":"ç®—æ³•","tags_index":"æ ‘çŠ¶æ•°ç»„,çº¿æ®µæ ‘,DFS","author_index":"LHY"},{"id":"36ef81d64d1d0edc64820d5afd16a0b4","title":"æ ‘çŠ¶æ•°ç»„","content":"åŸºæœ¬å†…å®¹12345678910111213141516171819202122232425262728293031323334// 1. å¼€å…¨å±€æ•°ç»„ï¼Œå¤§å°è¦æ¯”é¢˜ç›®è¦æ±‚çš„ N ç¨å¤§ä¸€ç‚¹// tree[] å°±æ˜¯æ ‘çŠ¶æ•°ç»„æœ¬ä½“int tree[500005]; int n; // é¢˜ç›®ç»™çš„æ•°ç»„é•¿åº¦// ------------------------------------------// ã€å‡½æ•° 1ã€‘lowbit// ä½œç”¨ï¼šç®—å‡º x äºŒè¿›åˆ¶æœ€å³è¾¹çš„ 1 ä»£è¡¨çš„å€¼int lowbit(int x) &#123;    return x &amp; -x;&#125;// ã€å‡½æ•° 2ã€‘add (å•ç‚¹ä¿®æ”¹)// ä½œç”¨ï¼šæŠŠç¬¬ x ä¸ªæ•°åŠ ä¸Š kvoid add(int x, int k) &#123;    // å¾ªç¯ï¼šä» x å¼€å§‹ï¼Œæ¯æ¬¡è·³åˆ°çˆ¶äº²èŠ‚ç‚¹ (i += lowbit(i))    // è¾¹ç•Œï¼šä¸èƒ½è¶…è¿‡æ€»é•¿åº¦ n    for (int i = x; i &lt;= n; i += lowbit(i)) &#123;        tree[i] += k;    &#125;&#125;// ã€å‡½æ•° 3ã€‘query (å‰ç¼€æ±‚å’Œ)// ä½œç”¨ï¼šç®—å‡º 1 åˆ° x ä¹‹é—´æ‰€æœ‰æ•°çš„å’Œint query(int x) &#123;    int sum = 0;    // å¾ªç¯ï¼šä» x å¼€å§‹ï¼Œæ¯æ¬¡å‡æ‰å½“å‰ç®¡è¾–é•¿åº¦ (i -= lowbit(i))    // è¾¹ç•Œï¼šç›´åˆ° i å˜æˆ 0    for (int i = x; i &gt; 0; i -= lowbit(i)) &#123;        sum += tree[i];    &#125;    return sum;&#125;\n\nè¿™é‡Œaddå‡½æ•°ç”¨æ¥ä¿®æ”¹ç¬¬iä¸ªæ•°ï¼Œqueryå‡½æ•°ç”¨æ¥æ±‚éƒ¨åˆ†å’Œã€‚\nä¸éš¾å‘ç°ï¼Œæ ‘çŠ¶æ•°ç»„ä¸­iæ¯æ¬¡æ°å¥½ä»æœ€å°ä¸º1çš„ä½ä¸Šè¿›ä½å¾—åˆ°çš„ä¸‹æ ‡æ˜¯æ‰€æœ‰åŒ…å«ç¬¬iä¸ªæ•°çš„ï¼Œä¹Ÿå°±æ˜¯å®ƒå…¨éƒ¨çš„ä¸Šçº§ã€‚é‚£ä¹ˆï¼Œå¯¹ç§°åœ°ï¼Œi -&#x3D; lowbit(i)å¾—åˆ°çš„å°±æ˜¯å…¨éƒ¨ä¸‹çº§ã€‚\nä»æ•°ç»„a[i]å»ºæ ‘çš„ä¸¤ç§æ–¹æ¡ˆ123456789101112131415161718192021//ä¸€ã€    // 1. å…ˆæŠŠæ ‘çŠ¶æ•°ç»„æ¸…ç©ºï¼ˆå¦‚æœæ˜¯å…¨å±€å˜é‡ï¼Œé»˜è®¤å°±æ˜¯0ï¼Œè¿™æ­¥å¯çœï¼‰    memset(tree, 0, sizeof(tree));     // 2. å€ŸåŠ©addå‡½æ•°åˆå§‹åŒ–    for (int i = 1; i &lt;= n; i++) &#123;        cin &gt;&gt; a[i];    // è¯»å…¥åŸæ•°ç»„        add(i, a[i]);   // ã€æ ¸å¿ƒã€‘ï¼šç›´æ¥æŠŠå€¼â€œåŠ â€è¿›æ ‘çŠ¶æ•°ç»„    &#125;//äºŒã€    // 1. å…ˆæŠŠåŸæ•°ç»„çš„å€¼ç›´æ¥æŠ„ç»™ tree    for (int i = 1; i &lt;= n; i++) &#123;       cin &gt;&gt; a[i];        tree[i] = a[i];     &#125;    // 2. æŒ‰ç…§æ ‘å½¢ç»“æ„ï¼Œè®©å„¿å­æŠŠå€¼åŠ ç»™çˆ¶äº²    for (int i = 1; i &lt;= n; i++) &#123;        int father = i + lowbit(i); // æ‰¾åˆ°å®ƒæ‰€æœ‰çš„ç›´æ¥ä¸Šçº§        if (father &lt;= n) &#123;            tree[father] += tree[i];         &#125;    &#125;\n\nè®¿é—®æ‰€æœ‰içš„å­èŠ‚ç‚¹123456789101112// å‡è®¾æˆ‘ä»¬è¦æ‰¾ x çš„æ‰€æœ‰ç›´æ¥å„¿å­void get_children(int x) &#123;    int lx = lowbit(x);     // éå†æ‰€æœ‰æ¯” lowbit(x) å°çš„ 2 çš„å¹‚æ¬¡    for (int k = 1; k &lt; lx; k &lt;&lt;= 1) &#123;        int child = x - k;    //è¿™é‡Œçš„æ¯ä¸ªchildéƒ½æ˜¯å­èŠ‚ç‚¹çš„ä¸‹æ ‡    &#125;&#125;æ³¨æ„ï¼Œå¯¹ä»»æ„child,åªè¦child + lowbit(child) = x,é‚£childå°±æ˜¯xçš„å­èŠ‚ç‚¹ã€‚å…¶ä¸­ï¼Œlowbit(child)æ˜¯2çš„æ¬¡æ–¹ã€‚æ‰€ä»¥è¦æ‰¾åˆ°æ‰€æœ‰å­èŠ‚ç‚¹ï¼Œåªè¦ç”¨ x å‡å»æ‰€æœ‰æ¯”å®ƒå°çš„ 2çš„æ¬¡å¹‚ å³å¯ã€‚\nä¸€äº›ç‰¹æ€§\ntree[x] å­˜å‚¨çš„æ˜¯åŒºé—´ (x - lowbit(x), x]\nå¯¹äºä¸€ä¸ªä¸‹æ ‡xï¼Œé‡å¤è®¡ç®—x + lowbit(x)å¯ä»¥å¾—åˆ°å®ƒçš„å…¨éƒ¨ä¸Šçº§\nå¯¹äºä¸€ä¸ªä¸‹æ ‡xï¼Œè®° t &#x3D; x - 2^k ï¼Œéå†æ‰€æœ‰ k ï¼Œå¾—åˆ°çš„å¤§äº0çš„tå³ä¸ºå…¶æ‰€æœ‰ç›´æ¥ä¸‹çº§èŠ‚ç‚¹\n\n","slug":"æ ‘çŠ¶æ•°ç»„","date":"2026-01-23T16:00:00.000Z","categories_index":"æ¿å­,ç®—æ³•","tags_index":"æ ‘çŠ¶æ•°ç»„","author_index":"LHY"},{"id":"fc6239ad7ae370c627b28fb8b9b9b920","title":"ç¬¬24æ¬¡CCFCSP T4:çº¿æ®µæ ‘","content":"åœ¨AIçš„è¾…åŠ©ä¸‹ï¼Œå‰å‰ååèŠ±äº†è¶…è¿‡5hæ—¶é—´ï¼Œç»ˆäºææ‡‚äº†è¿™é“é¢˜ã€‚å¥½æ¶ˆæ¯æ˜¯ï¼Œç°åœ¨åº”è¯¥æ˜¯ä»0å¼€å§‹è¾¾åˆ°äº†å¯ä»¥ç†Ÿç»ƒåº”ç”¨çº¿æ®µæ ‘äº†ã€‚ã€‚ã€‚é¡ºå¸¦è¿˜å­¦ä¼šäº†æ ‘çŠ¶æ•°ç»„ã€‚\né¢˜ç›®é“¾æ¥https://www.acwing.com/problem/content/description/4286/\nèƒ½è¿‡éƒ¨åˆ†æ ·ä¾‹çš„ä¸€ä¸ªè§£ç­”ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,k,cnt;struct nodes{    int ls=0,rs=0;//å·¦å³èŠ‚ç‚¹ä¸‹æ ‡    int id=0;int val=0;    int id_last=0;};vector&lt;nodes&gt; node;int newnode(){    ++cnt;    nodes a;    node.push_back(a);    return cnt;}void pushdown(int i,int l,int r){    if((node[i].id==-1)||(node[i].id==0&amp;&amp;node[i].val==0&amp;&amp;node[i].id_last==0)) return;    if(!node[i].ls) node[i].ls = newnode();    if(!node[i].rs)  node[i].rs = newnode();    int ls = node[i].ls;int rs = node[i].rs;    node[ls].id = node[i].id;node[ls].val = node[i].val;node[ls].id_last = node[i].id_last;    node[rs].id = node[i].id;node[rs].val = node[i].val;node[rs].id_last = node[i].id_last;    node[i].id = -1;}void update(int i,int l,int r,int id,int ll,int rr,int x){    if(ll&lt;=l&amp;&amp;r&lt;=rr){        node[i].id = id;node[i].val = x;        return;    }    else{                pushdown(i,l,r);        int mid = l+(r-l)/2;        if (ll &lt;= mid){             if (!node[i].ls) node[i].ls = newnode();            int ls = node[i].ls;            update(ls,l,mid,id,ll,rr,x);        }        if(mid&lt;rr){            if (!node[i].rs) node[i].rs = newnode();            int rs = node[i].rs;            update(rs,mid+1,r,id,ll,rr,x);        }        node[i].id = -1;    }}bool search1_x(int i,int l,int r,int id,int ll,int rr){//æŸ¥æ‰¾æŒ‡å®šåŒºé—´ä¸Šçš„èŠ‚ç‚¹çš„idæ˜¯å¦æ˜¯æŒ‡å®šid    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if(node[i].id==id) return true;        else if(node[i].id!=-1) return false;    }          pushdown(i,l,r);    int mid = l+(r-l)/2;    bool llv=false,rrv=false,lll=false,rrr=false;    if(mid&gt;=ll){        if(!node[i].ls) node[i].ls = newnode();        int ls=node[i].ls;        llv = search1_x(ls,l,mid,id,ll,rr);if(!llv) return false;        lll=true;    }    if(mid&lt;rr){        if(!node[i].rs) node[i].rs = newnode();        int rs=node[i].rs;        rrv = search1_x(rs,mid+1,r,id,ll,rr);if(!rrv) return false;        rrr=true;    }    bool jud1=false,jud2=false;    if((llv&amp;&amp;lll)||((!llv)&amp;&amp;(!lll))) jud1=true;    if((rrv&amp;&amp;rrr)||((!rrv)&amp;&amp;(!rrr))) jud2=true;    return jud1&amp;&amp;jud2;}void delete_x(int i,int l,int r,int id,int ll,int rr){        if(ll&lt;=l&amp;&amp;r&lt;=rr){            node[i].id = 0;            node[i].id_last = id;        }        else{            pushdown(i,l,r);            int mid = l+(r-l)/2;            if(mid&gt;=ll){                if(!node[i].ls) node[i].ls = newnode();                int ls=node[i].ls;                delete_x(ls,l,mid,id,ll,rr);            }            if(mid&lt;rr){                if(!node[i].rs) node[i].rs = newnode();                int rs=node[i].rs;                delete_x(rs,mid+1,r,id,ll,rr);            }            node[i].id = -1;        }}bool search2_x(int i,int l,int r,int id,int ll,int rr){//æŸ¥æ‰¾æŒ‡å®šåŒºé—´ä¸Šçš„èŠ‚ç‚¹çš„idæ˜¯å¦æ˜¯ç©ºçš„    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if(node[i].id==0&amp;&amp;node[i].id_last==id) return true;        else if(node[i].id!=-1) return false;    }    pushdown(i,l,r);    int mid = l+(r-l)/2;    bool llv=false,rrv=false,lll=false,rrr=false;    if(mid&gt;=ll){        if(!node[i].ls) node[i].ls = newnode();        int ls=node[i].ls;        llv = search2_x(ls,l,mid,id,ll,rr);if(!llv) return false;        lll=true;    }    if(mid&lt;rr){        if(!node[i].rs) node[i].rs = newnode();        int rs=node[i].rs;        rrv = search2_x(rs,mid+1,r,id,ll,rr);if(!rrv) return false;        rrr=true;    }    bool jud1=false,jud2=false;    if((llv&amp;&amp;lll)||((!llv)&amp;&amp;(!lll))) jud1=true;    if((rrv&amp;&amp;rrr)||((!rrv)&amp;&amp;(!rrr))) jud2=true;    return jud1&amp;&amp;jud2;    }void revive_x(int i,int l,int r,int id,int ll,int rr){        if(ll&lt;=l&amp;&amp;r&lt;=rr){            node[i].id=id;            node[i].id_last=0;        }        else{            pushdown(i,l,r);            int mid = l+(r-l)/2;            if(mid&gt;=ll){                if(!node[i].ls) node[i].ls = newnode();                int ls=node[i].ls;                revive_x(ls,l,mid,id,ll,rr);            }            if(mid&lt;rr){                if(!node[i].rs) node[i].rs = newnode();                int rs=node[i].rs;                revive_x(rs,mid+1,r,id,ll,rr);            }            node[i].id = -1;        }}pair&lt;int,int&gt; search_x(int i,int l,int r,int ll,int rr){    pair&lt;int,int&gt; a;    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if(node[i].id){            a.first=node[i].id;a.second=node[i].val;        }        else{            a.first=0;a.second=0;        }    }    else{        pushdown(i,l,r);        int mid = l+(r-l)/2;        if(mid&gt;=ll){            if(!node[i].ls) node[i].ls = newnode();            int ls=node[i].ls;            a = search_x(ls,l,mid,ll,rr);        }        if(mid&lt;rr){            if(!node[i].rs) node[i].rs = newnode();            int rs=node[i].rs;            a = search_x(rs,mid+1,r,ll,rr);        }    }    return a;}bool search3_x(int i,int l,int r,int id,int ll,int rr){//æŸ¥æ‰¾æŒ‡å®šåŒºé—´ä¸Šçš„èŠ‚ç‚¹çš„idæ˜¯å¦æ˜¯æŒ‡å®šidæˆ–è€…0    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if(node[i].id==id||node[i].id==0) return true;        else if(node[i].id==-1){            int mid = l+(r-l)/2;            int ls  = node[i].ls;int rs = node[i].rs;            return (search3_x(ls,l,mid,id,ll,rr)&amp;&amp;search3_x(rs,mid+1,r,id,ll,rr));        }        else return false;    }    else{                pushdown(i,l,r);        int mid = l+(r-l)/2;        bool llv=false,rrv=false,lll=false,rrr=false;        if(mid&gt;=ll){            if(!node[i].ls) node[i].ls = newnode();            int ls=node[i].ls;            llv = search3_x(ls,l,mid,id,ll,rr);if(!llv) return false;            lll=true;        }        if(mid&lt;rr){            if(!node[i].rs) node[i].rs = newnode();            int rs=node[i].rs;            rrv = search3_x(rs,mid+1,r,id,ll,rr);if(!rrv) return false;            rrr=true;        }        bool jud1=false,jud2=false;        if((llv&amp;&amp;lll)||((!llv)&amp;&amp;(!lll))) jud1=true;        if((rrv&amp;&amp;rrr)||((!rrv)&amp;&amp;(!rrr))) jud2=true;        return jud1&amp;&amp;jud2;    }}int find_limit(int i,int l,int r,int id,int ll,int rr){//æŸ¥æ‰¾[ll,rr]åŒºé—´ä¸Šï¼Œç¬¬ä¸€ä¸ªä¸æ˜¯æŒ‡å®šidçš„ä¸‹æ ‡    if(i==0) return -1;    if(ll&lt;=l&amp;&amp;r&lt;=rr){        if(node[i].id!=id&amp;&amp;node[i].id!=-1&amp;&amp;node[i].id!=0) return l;        else if(node[i].id==-1){            int mid = l + (r-l)/2;            int ls = node[i].ls;int rs = node[i].rs;            if(find_limit(ls,l,mid,id,ll,rr)==-1){                return find_limit(rs,mid+1,r,id,ll,rr);            }            else return find_limit(ls,l,mid,id,ll,rr);        }        else return -1;    }    else{           int mid = l+(r-l)/2;        int ls = node[i].ls;int rs = node[i].rs;        int a1 = find_limit(ls,l,mid,id,ll,rr);        if(ll&gt;mid) a1=-1;        if(a1 == -1){            int a2 = find_limit(rs,mid+1,r,id,ll,rr);            return a2;        }        else return a1;    }}int main(){     cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    nodes dummy;     node.push_back(dummy);    newnode();    while(k--){    int c;cin&gt;&gt;c;    if(c==0){        int id,l,r,x;cin&gt;&gt;id&gt;&gt;l&gt;&gt;r&gt;&gt;x;        if(search3_x(1,1,m,id,l,r)){            update(1,1,m,id,l,r,x);            cout&lt;&lt;r&lt;&lt;endl;        }        else{            int t = find_limit(1,1,m,id,l,r);            if(t-1&lt;l){                cout&lt;&lt;-1&lt;&lt;endl;            }            else{                update(1,1,m,id,l,t-1,x);                cout&lt;&lt;t-1&lt;&lt;endl;            }        }    }    else if(c==1){        int id,l,r;cin&gt;&gt;id&gt;&gt;l&gt;&gt;r;        if(search1_x(1,1,m,id,l,r)){            cout&lt;&lt;\"OK\"&lt;&lt;endl;            delete_x(1,1,m,id,l,r);        }        else cout&lt;&lt;\"FAIL\"&lt;&lt;endl;    }    else if(c==2){        int id,l,r;cin&gt;&gt;id&gt;&gt;l&gt;&gt;r;        if(search2_x(1,1,m,id,l,r)){            cout&lt;&lt;\"OK\"&lt;&lt;endl;            revive_x(1,1,m,id,l,r);        }        else cout&lt;&lt;\"FAIL\"&lt;&lt;endl;    }    else{        int p;cin&gt;&gt;p;        pair&lt;int,int&gt; a = search_x(1,1,m,p,p);        cout&lt;&lt;a.first&lt;&lt;\" \"&lt;&lt;a.second&lt;&lt;endl;    }    }    return 0;}\nå¤æ‚åº¦åˆ†ææœ€åæƒ…å†µä¸‹ï¼Œç©ºé—´å¤æ‚åº¦å¤§æ¦‚æ˜¯ ï¼Œæ—¶é—´å¤æ‚åº¦å¤§æ¦‚æ˜¯ï¼Œè¿™ä¸ªå°±æ˜¯è¶…æ—¶çš„åŸå› ã€‚\nä¸€äº›ç»†èŠ‚1ï¼Œç”±äºæ˜¯åŠ¨æ€å¼€ç‚¹ï¼Œéœ€è¦ä¸€ä¸ªå…¨å±€è®¡æ•°å™¨cntæ¥è®°å½•å¯¹åº”çš„èŠ‚ç‚¹ç´¢å¼•ã€‚åŒæ—¶ï¼ŒæŠŠæ–°å»ºèŠ‚ç‚¹å°è£…è¿›newcode()å‡½æ•°é‡Œï¼Œè¿™æ ·ä¹Ÿçœçš„ä¸€è¾¹è¦ç»´æŠ¤nodeæ•°ç»„ä¸€è¾¹ç»´æŠ¤è®¡æ•°å™¨ã€‚\n2ï¼Œpushdownå‡½æ•°ã€‚    ç”±äºåœ¨éœ€è¦æ ‘æåˆ†å‰æ—¶ï¼Œæœ‰ä¸€äº›å±æ€§éœ€è¦ä»çˆ¶èŠ‚ç‚¹ä¼ é€’åˆ°å­èŠ‚ç‚¹ï¼Œè¿™é‡Œä½¿ç”¨pushdownå‡½æ•°æ¥å®Œæˆè¿™ä¸ªåŠŸèƒ½ã€‚ä½†æ˜¯ï¼Œä¼ é€’ä¹‹åï¼Œæœ‰äº›å±æ€§å‡ºç°åˆ†åŒ–ï¼Œæ¯”å¦‚å·¦å­èŠ‚ç‚¹çš„idä¸ç­‰äºå³å­èŠ‚ç‚¹çš„idï¼Œè¿™ç§æ—¶å€™å°±éœ€è¦æŠŠçˆ¶èŠ‚ç‚¹çš„idä¿®æ”¹æˆç‰¹æ®Šå€¼-1ã€‚å®é™…ä¸Šï¼Œè¿™ä¸ª-1åœ¨åç»­ç»´æŠ¤å…¶ä»–å‡½æ•°çš„è¿‡ç¨‹ä¸­é€ æˆäº†éå¸¸å¤§çš„éº»çƒ¦ï¼Œä½†è¿™ä¸€æ­¥åˆçœä¸æ‰ï¼Œéå¸¸ä¹‹éº»çƒ¦ã€‚ã€‚\n3ï¼Œå…¶ä»–çš„å‡½æ•°æ²¡ä»€ä¹ˆå¯è¯´çš„ï¼ŒåŸºæœ¬ä¸Šéƒ½æ˜¯ç”¨äº†DFSçš„æ–¹æ³•å®ç°äº†æ‰€éœ€è¦çš„ä¸€äº›æ“ä½œã€‚\n4ï¼Œå€¼å¾—ä¸€æçš„æ˜¯è¿™é‡Œçš„find_limitå‡½æ•°ï¼Œå®ƒå®ç°äº†ä»å·¦åˆ°å³æ‰¾ç¬¦åˆæ¡ä»¶çš„ä¸‹æ ‡ï¼Œè¿™é‡Œçš„ä»å·¦åˆ°å³ï¼Œå°±é€šè¿‡â€œå…ˆè®¿é—®å·¦å­èŠ‚ç‚¹ï¼Œå·¦å­èŠ‚ç‚¹æ²¡æœ‰ç»“æœå†è®¿é—®å³å­èŠ‚ç‚¹â€è¿™æ ·ä¸€ä¸ªç®€å•çš„ç»“æ„å®ç°ã€‚\næ”¹è¿›æ–¹æ³•æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œé—®é¢˜æœ¬è´¨ä¸Šæ˜¯å‡ºç°åœ¨æ—¶é—´å¤æ‚åº¦é‡Œçš„è¿™ä¸ªã€‚å®ƒæ¥è‡ªäºï¼Œæ¯ä¸€æ¬¡æŸ¥è¯¢ï¼Œå¦‚æœå½“å‰èŠ‚ç‚¹å·²ç»å‘ä¸‹åˆ†å‰ï¼Œæ¯”å¦‚node[i].id=-1è¿™ç§æƒ…å†µå‡ºç°ï¼Œé‚£ä¹ˆå°±å¿…é¡»å¾€ä¸‹æŸ¥è¯¢å…¶å­èŠ‚ç‚¹ï¼Œè¿™å°±ä¼šå¯¼è‡´éå¸¸æ¶å¿ƒçš„æƒ…å†µã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦å¢åŠ èŠ‚ç‚¹çš„æˆå‘˜ï¼ŒåŒæ—¶å¢åŠ ä¸€ä¸ªpushupå‡½æ•°æ¥å°†å­èŠ‚ç‚¹çš„ä¿¡æ¯ç»´æŠ¤åˆ°çˆ¶èŠ‚ç‚¹ä¸Šï¼Œå®ç°æ›´é«˜æ•ˆçš„æŸ¥è¯¢\n123456789101112131415161718192021struct nodes {    int ls = 0, rs = 0;    int id = 0; int val = 0;    int id_last = 0;//ä¸‹é¢ä¸ºæ–°å¢æˆå‘˜    int min_id = 0;     int max_id = 0; };void pushup(int i) {    int ls = node[i].ls;    int rs = node[i].rs;    // å¦‚æœå­©å­å­˜åœ¨ï¼Œå°±å–å­©å­çš„ min/maxï¼›å¦‚æœå­©å­ä¸å­˜åœ¨ï¼Œé»˜è®¤æ˜¯ç©ºåœ°(ID=0)    int l_min = ls ? node[ls].min_id : 0;    int l_max = ls ? node[ls].max_id : 0;    int r_min = rs ? node[rs].min_id : 0;    int r_max = rs ? node[rs].max_id : 0;    // è‡ªå·±çš„ä¿¡æ¯ = å·¦å³å­©å­çš„æå€¼    node[i].min_id = min(l_min, r_min);    node[i].max_id = max(l_max, r_max);}\nå½“ç„¶ï¼Œå¢åŠ ä¸Špushupå‡½æ•°ï¼Œè‚¯å®šä¹Ÿéœ€è¦é‡æ„ä»£ç ä¸­ç”¨åˆ°çš„å…¶ä»–å‡½æ•°ã€‚\nä¸€äº›æ„Ÿæ‚Ÿ\næ­¤å¤„çš„pushupå‡½æ•°æ˜¯å¯¹å­èŠ‚ç‚¹ä¿¡æ¯çš„æœ‰æŸå‹ç¼©ã€‚  ç”±äºåœ¨æœ¬é¢˜ä¸­ï¼Œåªéœ€è¦åˆ¤æ–­ä¸€ä¸ªèŠ‚ç‚¹åŒ…å«çš„åŒºé—´å†…ï¼Œæ¯ä¸ªç‚¹çš„idæ˜¯å¤šå°‘ï¼Œæ‰€ä»¥åªéœ€è¦åˆ¤æ–­node[i].min_id==node[i].max_idè¿™ä¸ªè¡¨è¾¾å¼çš„å€¼å³å¯ï¼Œè¿™ç§å‹ç¼©æ–¹å¼å·²ç»è¶³å¤Ÿäº†ã€‚  ä½†æ˜¯å¯¹äºå…¶ä»–çš„é¢˜ç›®ï¼Œæœ‰æ›´å¤šæ„å»ºpushupå‡½æ•°çš„æ–¹æ³•ï¼Œå…¶æ ¸å¿ƒå‡åœ¨äºå‘ä¸Šçº§èŠ‚ç‚¹æ±‡æ€»ä¿¡æ¯ï¼›æœ¬è´¨ä¸Šï¼Œæ˜¯å¯¹äºçº¿æ®µæ ‘ä¿¡æ¯å‘ä¸‹åˆ†åŒ–çš„é€†è¿ç®—ã€‚\nè™½ç„¶æ²¡æœ‰å®Œå…¨åšå‡ºæ¥ï¼Œæˆ‘çš„åšæ³•èµ·ç å¤„ç†äº†m = 1e9è¿™æ ·çš„ä¸œè¥¿ï¼Œæ¯”çº¯ç²¹çš„æš´åŠ›æ³•åº”è¯¥è¿˜æ˜¯ç•¥èƒœä¸€ç­¹çš„ã€‚\n\nACçš„è§£ç­”ä»£ç é“¾æ¥ï¼šé¢˜è§£æ¥æº\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;assert.h&gt;using namespace std;#define FREE 0#define OCCUPIED 1#define ZOMBIE 2#define N_MAX 200005#define MIXED 2000000020#define FULL (-2000000020)struct FILE_BLOCK {    int l, r;    int x;  // value: -1e9~1e9, 2e9: mixed    int id; // id: 1~n(&lt;2e5), 2e9: mixed    int state;  // FREE, OCCUPIED, ZOMBIE, 2e9: mixed};struct OPRT {    OPRT(int t, int i, int ll, int rr, int xx, int pp) : type(t), id(i), l(ll), r(rr), x(xx), p(pp) {}    int type, id, l, r, x, p;};int n, m, k;vector&lt;FILE_BLOCK&gt; fb(N_MAX &lt;&lt; 4);vector&lt;OPRT&gt; oprt;vector&lt;int&gt; coordinates;int discretization() {    coordinates.push_back(0);   // let coordinates begin with 1    sort(coordinates.begin(), coordinates.end());    m = unique(coordinates.begin(), coordinates.end()) - coordinates.begin();   // 1~m    coordinates.resize(m);    for (auto &amp; op : oprt) {        switch (op.type) {            case 0: case 1: case 2:                op.l = lower_bound(coordinates.begin(), coordinates.end(), op.l) - coordinates.begin();                op.r = lower_bound(coordinates.begin(), coordinates.end(), op.r) - coordinates.begin();                break;            case 3: default:                op.p = lower_bound(coordinates.begin(), coordinates.end(), op.p) - coordinates.begin();                break;        }    }    return 0;}void pushup(int curr) {    if (fb[curr&lt;&lt;1].id == fb[curr&lt;&lt;1|1].id) fb[curr].id = fb[curr&lt;&lt;1].id;    else fb[curr].id = MIXED;    if (fb[curr&lt;&lt;1].x == fb[curr&lt;&lt;1|1].x) fb[curr].x = fb[curr&lt;&lt;1].x;    else fb[curr].x = MIXED;    if (fb[curr&lt;&lt;1].state == fb[curr&lt;&lt;1|1].state) fb[curr].state = fb[curr&lt;&lt;1].state;    else fb[curr].state = MIXED;}/* f5 */void build(int curr, int l, int r){    fb[curr].l = l;    fb[curr].r = r;    if (l == r) return;    else {        int mid = l+((r-l)&gt;&gt;1);     // ç”¨å‡æ³•ä¸ç”¨åŠ æ³•ï¼Œé¿å…çˆ†int        build(curr&lt;&lt;1, l, mid);        build((curr&lt;&lt;1)+1, mid+1, r);        pushup(curr);    }}void pushdown(int curr) {    if (fb[curr].r != fb[curr].l) {        if(fb[curr].id != MIXED) fb[curr &lt;&lt; 1].id = fb[curr &lt;&lt; 1 | 1].id = fb[curr].id;        if(fb[curr].state != MIXED) fb[curr &lt;&lt; 1].state = fb[curr &lt;&lt; 1 | 1].state = fb[curr].state;        if(fb[curr].x != MIXED) fb[curr &lt;&lt; 1].x = fb[curr &lt;&lt; 1 | 1].x = fb[curr].x;    }}/* Interval change *//* update_test: Find the rightmost available to_r */int update_test(int curr, int to_l, int id) {    if (fb[curr].state == FREE || fb[curr].state == ZOMBIE || fb[curr].id == id) return fb[curr].r;    else if (fb[curr].state == OCCUPIED &amp;&amp; fb[curr].id != MIXED) return FULL;   // debug: state = mixed, maybe itself    else {  // state == mixed        int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);        pushdown(curr);        if (to_l &lt;= mid) {            int left_r = update_test(curr&lt;&lt;1, to_l, id);            if (left_r &lt; mid) return left_r;            int right_r = update_test(curr&lt;&lt;1|1, to_l, id);            return right_r == FULL ? left_r : right_r;        }        else {            return update_test(curr&lt;&lt;1|1, to_l, id);        }    }};void update_ic(int curr, int to_l, int to_r, int x, int id) {    if (fb[curr].l == to_l &amp;&amp; fb[curr].r == to_r) { // åˆšå¥½è¦†ç›–        fb[curr].state = OCCUPIED;        fb[curr].id = id;        fb[curr].x = x;        return;    }    int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);    pushdown(curr);    if (to_l &lt;= mid) update_ic(curr&lt;&lt;1, to_l, min(to_r, mid), x, id);    if (to_r &gt; mid) update_ic(curr&lt;&lt;1|1, max(to_l, mid+1), to_r, x, id);    pushup(curr);};/* Interval deletion */bool deletion_test (int curr, int to_l, int to_r, int id) {    if (fb[curr].l == to_l &amp;&amp; fb[curr].r == to_r) { // åªåœ¨å®Œå…¨åŒ¹é…çš„æ—¶å€™ä½œåˆ¤æ–­        if (fb[curr].state == OCCUPIED &amp;&amp; fb[curr].id == id) return true;        else return false;    }    int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);    pushdown(curr);    bool avai = true;    if (to_l &lt;= mid) avai &amp;= deletion_test(curr&lt;&lt;1, to_l, min(to_r, mid), id);    if (to_r &gt; mid) avai &amp;= deletion_test(curr&lt;&lt;1|1, max(to_l, mid+1), to_r, id);    return avai;}void deletion (int curr, int to_l, int to_r, int id) {    if (fb[curr].l == to_l &amp;&amp; fb[curr].r == to_r) {        fb[curr].state = ZOMBIE;        return;    }    int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);    pushdown(curr);    if (to_l &lt;= mid) deletion(curr&lt;&lt;1, to_l, min(to_r, mid), id);    if (to_r &gt; mid) deletion(curr&lt;&lt;1|1, max(to_l, mid+1), to_r, id);    pushup(curr);}/* Interval recovery */bool recover_test (int curr, int to_l, int to_r, int id) {    if (fb[curr].l == to_l &amp;&amp; fb[curr].r == to_r) {        if (fb[curr].state == ZOMBIE &amp;&amp; fb[curr].id == id) return true;        else return false;    }    int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);    pushdown(curr);    bool avai = true;    if (to_l &lt;= mid) avai &amp;= recover_test(curr&lt;&lt;1, to_l, min(to_r, mid), id);    if (to_r &gt; mid) avai &amp;= recover_test(curr&lt;&lt;1|1, max(to_l, mid+1), to_r, id);    return avai;}void recover (int curr, int to_l, int to_r, int id) {    if (fb[curr].l == to_l &amp;&amp; fb[curr].r == to_r) {        fb[curr].state = OCCUPIED;        return;    }    int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);    pushdown(curr);    if (to_l &lt;= mid) recover(curr&lt;&lt;1, to_l, min(to_r, mid), id);    if (to_r &gt; mid) recover(curr&lt;&lt;1|1, max(to_l, mid+1), to_r, id);    pushup(curr);}/* query */int query (int curr, int p) {    if (fb[curr].l == fb[curr].r) return curr;    else if (fb[curr].state != MIXED &amp;&amp; fb[curr].id != MIXED &amp;&amp; fb[curr].x != MIXED) return curr;    else {        int mid = fb[curr].l+((fb[curr].r-fb[curr].l)&gt;&gt;1);        pushdown(curr);        if (p &lt;= mid) return query(curr&lt;&lt;1, p);        else return query(curr&lt;&lt;1|1, p);    }}int main() {    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);    int type=0, id=0, l=0, r=0, x=0, p=0;    for (int i = 0; i &lt; k; i++) {        scanf(\"%d\", &amp;type);        switch (type) {            case 0:                scanf(\"%d%d%d%d\", &amp;id, &amp;l, &amp;r, &amp;x);                oprt.emplace_back(type, id, l, r, x, 0);                break;            case 1:                scanf(\"%d%d%d\", &amp;id, &amp;l, &amp;r);                oprt.emplace_back(type, id, l, r, 0, 0);                break;            case 2:                scanf(\"%d%d%d\", &amp;id, &amp;l, &amp;r);                oprt.emplace_back(type, id, l, r, 0, 0);                break;            case 3:                scanf(\"%d\", &amp;p);                oprt.emplace_back(type, 0, 0, 0, 0, p);                break;            default:                break;        }        if (type == 0 || type == 1 || type == 2) {            coordinates.push_back(l);            coordinates.push_back(r);            if (l != 1) coordinates.push_back(l-1);     // æ³¨æ„ç¦»æ•£åŒ–è¦åŠ å…¥å‰åçš„ç‚¹            if (r != m) coordinates.push_back(r+1);        }        else {            coordinates.push_back(p);        }    }    /* ç¦»æ•£åŒ– */    discretization();    /* å»ºæ ‘ */    build(1, 1, m-1);    int query_index;    for (auto &amp; op : oprt) {        switch (op.type) {            case 0:                op.r = min(op.r, update_test(1, op.l, op.id));                if (op.r != FULL) update_ic(1, op.l, op.r, op.x, op.id);                printf(\"%d\\n\", op.r==FULL?-1:coordinates[op.r]);                break;            case 1:                if (deletion_test(1, op.l, op.r, op.id)) {                    deletion(1, op.l, op.r, op.id);                    printf(\"OK\\n\");                }                else {                    printf(\"FAIL\\n\");                }                break;            case 2:                if (recover_test(1, op.l, op.r, op.id)) {                    recover(1, op.l, op.r, op.id);                    printf(\"OK\\n\");                }                else printf(\"FAIL\\n\");                break;            case 3:                query_index = query(1, op.p);                if (fb[query_index].state != OCCUPIED) printf(\"%d %d\\n\", 0, 0);                else printf(\"%d %d\\n\", fb[query_index].id, fb[query_index].x);                break;            default:                break;        }    }    return 0;}\n","slug":"ç¬¬24æ¬¡CCFCSP T4ï¼šçº¿æ®µæ ‘","date":"2026-01-23T16:00:00.000Z","categories_index":"ç®—æ³•,CSPçœŸé¢˜","tags_index":"çº¿æ®µæ ‘,DFS","author_index":"LHY"},{"id":"2e56aa1cb1c783bcbdadc98ed10245b3","title":"LaTeXè¯­æ³•","content":"å¯¹äºè¡Œå†…å…¬å¼ï¼Œéœ€è¦ç”¨$æ¥åŒ…è£¹ï¼›å¯¹äºè·¨è¡Œå…¬å¼ï¼Œéœ€è¦ç”¨$$æ¥åŒ…è£¹\nä¸‹æ ‡: dp_i  \nå°äºç­‰äº: \\le \nå¤§äºç­‰äº: \\ge \nä¸ç­‰å·: \\neq \næ±‚å’Œ: \\sum_{i=1}^{n} \nå³ç®­å¤´: \\rightarrow  ç±»ä¼¼åœ°ä¹Ÿæœ‰å·¦ç®­å¤´\nå‰ä¹˜: \\times \nç‚¹ä¹˜: \\cdot \nåŒ…å«äºæˆ–ç­‰äº: \\subseteq \n","slug":"LaTeXè¯­æ³•","date":"2026-01-22T16:00:00.000Z","categories_index":"ä¸€äº›å·¥å…·","tags_index":"","author_index":"LHY"},{"id":"50b6cecadbf73c890733ae7113a0eab2","title":"è·¯å¾„æ€»å’Œ","content":"é¢˜ç›®ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œå®ƒçš„æ¯ä¸ªç»“ç‚¹éƒ½å­˜æ”¾ç€ä¸€ä¸ªæ•´æ•°å€¼ï¼æ‰¾å‡ºè·¯å¾„å’Œç­‰äºç»™å®šæ•°å€¼çš„è·¯å¾„æ€»æ•°ï¼è·¯å¾„ä¸éœ€è¦ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä¹Ÿä¸éœ€è¦åœ¨å¶å­èŠ‚ç‚¹ç»“æŸï¼Œä½†æ˜¯è·¯å¾„æ–¹å‘å¿…é¡»æ˜¯å‘ä¸‹çš„ï¼ˆåªèƒ½ä»çˆ¶èŠ‚ç‚¹åˆ°å­èŠ‚ç‚¹ï¼‰ï¼\nå®ç°åªéœ€è¦ä¸¤ä¸ªé€’å½’çš„å‡½æ•°\n123456int count(TreeNode *node, int sum) &#123;  if (node == nullptr) return 0;  return (node-&gt;val == sum) + count(node-&gt;left, sum - node-&gt;val) +         count(node-&gt;right, sum - node-&gt;val);&#125;//count(a,b)è¡¨ç¤ºï¼Œä»aèŠ‚ç‚¹å‡ºå‘ï¼Œå‘ä¸‹æ±‚è·¯å¾„èŠ‚ç‚¹å€¼çš„æ€»å’Œï¼Œè¯¥æ€»å’Œç­‰äºbçš„è·¯å¾„æœ‰å¤šå°‘ã€‚\n\n123456int pathSum(TreeNode *root, int sum) &#123;  if (root == nullptr) return 0;  return count(root, sum) + pathSum(root-&gt;left, sum) +         pathSum(root-&gt;right, sum);&#125;//pathSum(a,b)è¡¨ç¤ºï¼Œä»aèŠ‚ç‚¹å‡ºå‘ï¼Œå‘ä¸‹æ±‚è·¯å¾„èŠ‚ç‚¹å€¼çš„æ€»å’Œï¼Œè¯¥æ€»å’Œç­‰äºbçš„è·¯å¾„æœ‰å¤šå°‘ã€‚\næ­¤æ—¶åªè¦æŠŠæ ¹èŠ‚ç‚¹ã€ç»™å®šçš„sumä¸¢ç»™pathSumå‡½æ•°å°±èƒ½è·‘å‡ºæ¥ç­”æ¡ˆã€‚ç›´è§‰ä¸Šï¼Œæˆ‘æ„Ÿè§‰pathSumæ­¤å¤„çš„åŠŸèƒ½æœ‰ç‚¹ç±»ä¼¼äºå‰ç¼€å’Œã€‚\n\n\n\n\n\n\n\n\n\néå¸¸ç²¾å·§çš„é€’å½’ç»“æ„ã€‚\n","slug":"è·¯å¾„æ€»å’Œ","date":"2026-01-22T16:00:00.000Z","categories_index":"ç®—æ³•","tags_index":"DFS","author_index":"LHY"},{"id":"497c15de710957392d86e4d03043dcbb","title":"å‰ç¼€å’Œã€å­é›†å’Œä»¥åŠDP","content":"å‰ç¼€å’Œè®°\n\n\n\né‚£ä¹ˆ  å°±è¡¨ç¤ºäº†kç»´çš„å‰ç¼€å’Œï¼Œéœ€è¦ä½¿ç”¨éƒ¨åˆ†å’Œæ—¶ç›´æ¥å°†ä¸‹æ ‡è¾“å…¥è®¡ç®—å·®å€¼å³å¯ã€‚\n\n\n\n\n\n\n\n\n\næœ¬è´¨å³ç©ºé—´æ¢æ—¶é—´\nå­é›†å’Œè€ƒè™‘å¤§å°ä¸º ğ‘› çš„é›†åˆçš„å…¨ä½“å­é›†ä¸Šé¢å®šä¹‰çš„å‡½æ•° ğ‘“ ï¼Œç°åœ¨è¦æ±‚å‡ºå…¶å­é›†å’Œå‡½æ•° ğ‘” ï¼Œå®ƒæ»¡è¶³ \n123456for (int i = 0; i &lt; n; ++i) // éå†æ¯ä¸€ä¸ªç»´åº¦ï¼ˆå³äºŒè¿›åˆ¶çš„ç¬¬ i ä½ï¼‰    for (int mask = 0; mask &lt; (1 &lt;&lt; n); ++mask) // éå†æ‰€æœ‰çŠ¶æ€        if (mask &amp; (1 &lt;&lt; i)) // å¦‚æœå½“å‰çŠ¶æ€çš„ç¬¬ i ä½æ˜¯ 1            f[mask] += f[mask ^ (1 &lt;&lt; i)]; // å°†â€œç¬¬ i ä½æ˜¯ 0â€çš„å­é›†è´¡çŒ®ç´¯åŠ è¿‡æ¥//åŒ…å«çŠ¶æ€å‹ç¼©ï¼Œå³ç”¨ä¸€ä¸ªäºŒè¿›åˆ¶ä¸‹nä½çš„æ•°å­—å­˜å‚¨æŸä¸ªå­é›†ã€‚næ˜¯Sçš„å…ƒç´ ä¸ªæ•°ã€‚//f[mask] è¡¨ç¤ºçš„æ˜¯ æ‰€æœ‰å±äº mask å­é›†çš„çŠ¶æ€çš„åˆå§‹å‡½æ•°å€¼ä¹‹å’Œã€‚\n\n\n","slug":"å‰ç¼€å’Œã€å­é›†å’Œä»¥åŠDP","date":"2026-01-22T16:00:00.000Z","categories_index":"ç®—æ³•","tags_index":"DP,å‰ç¼€å’Œ","author_index":"LHY"},{"id":"8577172d587822c13c6c2f341014a5ff","title":"Markdownè¯­æ³•","content":"æ ‡é¢˜ï¼š# title    å…¶ä¸­ï¼Œ#çš„ä¸ªæ•°å³ä»£è¡¨ä¸ºå‡ çº§æ ‡é¢˜ã€‚\nåŠ ç²—ï¼š**æ–‡å­—**\nåˆ—è¡¨ï¼š- åˆ—è¡¨å…ƒç´  å¯ç”¨ç¼©è¿›è¡¨ç¤ºåµŒå¥—åˆ—è¡¨     1.,2. å³æœ‰åºæ•°å­—åˆ†éš”\né“¾æ¥ï¼š[æ–‡å­—](é“¾æ¥)\nå›¾ç‰‡ï¼š![æè¿°](å›¾ç‰‡è·¯å¾„)\n\n\n\n\n\n\n\n\n\nå¦‚æœæ˜¯ç½‘ç»œå›¾ç‰‡ï¼Œç›´æ¥æ”¾å…¥å…¶è·¯å¾„å³å¯å¦‚æœæ˜¯æœ¬åœ°å›¾ç‰‡ï¼Œå¯å°†å›¾ç‰‡æ”¾å…¥C:\\MyBlog\\source\\images\\æ–‡ä»¶å¤¹ï¼Œè·¯å¾„ä¸ºC:\\MyBlog\\source\\images\\\nå¼•ç”¨ï¼š&gt; å†…å®¹\nä»£ç ï¼š```languagetype + code``` or ` code`\nåœ¨Front-matterä¸­ï¼š    top: 100  &lt;â€“ è‡ªå®šä¹‰ä¸€ä¸ªæ•°å­—ï¼Œæ•°å­—è¶Šå¤§è¶Šé å‰    recommend: true å°†ä¼šå‡ºç°åœ¨æ¨èæ     mathjax: true å¯ä»¥ä½¿ç”¨æ•°å­¦å…¬å¼è¯­æ³•\n{% raw %} â€¦ {% endraw %}:    æ˜¯ Hexo çš„æœ€é«˜çº§æŒ‡ä»¤ã€‚å®ƒå‘Šè¯‰ç¼–è¯‘å™¨ï¼šâ€œè¿™ä¸­é—´çš„æ‰€æœ‰å­—ç¬¦ï¼ˆåŒ…æ‹¬ä¸‹åˆ’çº¿ã€èŠ±æ‹¬å·ã€å¼•å·ï¼‰ï¼Œä½ ä¸€ä¸ªéƒ½åˆ«åŠ¨ï¼ŒåŸå°ä¸åŠ¨åœ°äº¤ç»™ MathJax å»å¤„ç†ã€‚â€\n","slug":"Markdownè¯­æ³•","date":"2026-01-21T16:00:00.000Z","categories_index":"ä¸€äº›å·¥å…·","tags_index":"","author_index":"LHY"},{"id":"170e82ce52ebeae7a2973224969d3bd2","title":"æ¡¶ï¼šå€¼ä¸ä¸‹æ ‡","content":"â€œæ¡¶â€ï¼ˆBucketï¼‰é€šå¸¸ä¸æ˜¯æŒ‡æŸä¸€ä¸ªç‰¹å®šçš„æ ‡å‡†æ¨¡æ¿åº“ï¼ˆSTLï¼‰å®¹å™¨ï¼Œè€Œæ˜¯ä¸€ç§æ€æƒ³æˆ–æ•°æ®ç»„ç»‡æ–¹å¼ã€‚å®ƒçš„æ ¸å¿ƒé€»è¾‘æ˜¯ï¼šåˆ©ç”¨æ•°ç»„ä¸‹æ ‡æ¥ä»£è¡¨æ•°æ®çš„å€¼ï¼ˆæˆ–å€¼çš„èŒƒå›´ï¼‰ï¼Œç”¨æ•°ç»„å…ƒç´ æ¥å­˜å‚¨è¯¥å€¼çš„å±æ€§ï¼ˆå¦‚å‡ºç°æ¬¡æ•°ã€å­˜åœ¨æ€§ç­‰ï¼‰ã€‚\n\n\n\n\n\n\n\n\n\nç”¨é€”  1.æœç´¢  ç±»ä¼¼mapçš„é”®ï¼Œå°†æŸä¸ªå€¼ä½œä¸ºé”®å¯ä»¥å¿«é€ŸæŸ¥è¯¢å…¶ç›¸å…³çš„å±æ€§ï¼ˆå€¼ï¼‰ï¼Œå¦‚å­˜åœ¨æ€§ã€å‡ºç°æ¬¡æ•°ã€‚  2.è¾…åŠ©æ•°æ®ç»“æ„  åœ¨å›¾è®ºä¸­ï¼Œè¿™ç§æ€æƒ³æ˜¯æ„å»ºå¤æ‚ç»“æ„çš„åŸºç¡€ã€‚    å¹¶æŸ¥é›† (Union-Find)ï¼šæ•°ç»„ parent[i] &#x3D; kã€‚        å«ä¹‰ï¼šä¸‹æ ‡ i ä»£è¡¨èŠ‚ç‚¹ iï¼Œå€¼ k ä»£è¡¨å®ƒçš„çˆ¶èŠ‚ç‚¹æ˜¯ kã€‚è¿™é‡Œå®Œå…¨ä¾èµ–â€œèŠ‚ç‚¹ç¼–å·â€ä½œä¸ºæ•°ç»„ä¸‹æ ‡æ¥å¿«é€Ÿç´¢å¼•ã€‚    é‚»æ¥è¡¨ (å­˜å‚¨å›¾çš„æ•°æ®ç»“æ„)ï¼švector adj[N]ã€‚        å«ä¹‰ï¼šadj[u] å­˜å‚¨çš„æ˜¯èŠ‚ç‚¹ u çš„æ‰€æœ‰é‚»å±…ã€‚ç›´æ¥ç”¨ u çš„ç¼–å·å»è®¿é—®ã€‚\næœ¬è´¨å³ç©ºé—´æ¢æ—¶é—´ã€‚\n\n\n\n\n\n\n\n\n\nè¡¥å……å¹¶æŸ¥é›†ï¼šå…³æ³¨ä¸€ä¸ªå›¾ä¸­èŠ‚ç‚¹çš„è¿é€šæ€§ï¼Œé€šå¸¸ç”¨äºè§£å†³æ¶‰åŠå¤šä¸ªèŠ‚ç‚¹é—´æ˜¯å¦è¿é€šçš„é—®é¢˜\n123456789101112131415161718192021222324252627282930313233343536373839vector&lt;int&gt; parent; // ä¸‹æ ‡=å…ƒç´ ï¼Œå€¼=çˆ¶èŠ‚ç‚¹vector&lt;int&gt; rank_;  // æŒ‰ç§©åˆå¹¶ï¼ˆç§©=æ ‘çš„é«˜åº¦ï¼‰ï¼Œé¿å…æ ‘é€€åŒ–æˆé“¾è¡¨// åˆå§‹åŒ–ï¼šn ä¸ºå…ƒç´ æ€»æ•°ï¼ˆå…ƒç´ ç¼–å·é€šå¸¸ä» 0 æˆ– 1 å¼€å§‹ï¼Œéœ€åŒ¹é…é¢˜ç›®ï¼‰void init(int n) &#123;    parent.resize(n);    rank_.resize(n, 1); // åˆå§‹æ¯ä¸ªé›†åˆçš„ç§©ä¸º 1    for (int i = 0; i &lt; n; i++) &#123;        parent[i] = i; // åˆå§‹æ¯ä¸ªå…ƒç´ çš„çˆ¶èŠ‚ç‚¹æ˜¯è‡ªå·±ï¼ˆæ ¹èŠ‚ç‚¹ï¼‰    &#125;&#125;// æŸ¥æ‰¾ï¼šæ‰¾å…ƒç´  x çš„æ ¹èŠ‚ç‚¹ï¼Œå¸¦è·¯å¾„å‹ç¼©ï¼ˆæ ¸å¿ƒä¼˜åŒ–ï¼‰int find(int x) &#123;    if (parent[x] != x) &#123;        parent[x] = find(parent[x]); // é€’å½’å‹ç¼©è·¯å¾„ï¼Œx ç›´æ¥æŒ‡å‘æ ¹    &#125;    return parent[x]; // è¿”å›æ ¹èŠ‚ç‚¹&#125;æ­¤å¤„ï¼Œæ— è®ºæœ€ç»ˆé€’å½’å¤šå°‘æ¬¡ï¼Œæœ€ç»ˆè¿”å›çš„éƒ½æ˜¯è¾“å…¥å€¼xçš„æœ€ç»ˆçš„ç¥–å®—å¹¶ä¸”ï¼Œxçš„æ‰€æœ‰çš„çˆ¹ï¼Œéƒ½ä¼šè¢«èµ‹å€¼è¿™ä¸ªç¥–å®—ï¼Œä¹Ÿå°±æ˜¯æ¯”å®ƒé«˜çº§çš„éƒ½ä¼šè¢«èµ‹å€¼æœ€ç»ˆç”¨ä¸‹æ ‡ä»£è¡¨è‡ªå·±ï¼Œç”¨parent[x]è¡¨ç¤ºè‡ªå·±çš„ç¥–å®—// åˆå¹¶ï¼šåˆå¹¶ x å’Œ y æ‰€å±çš„é›†åˆï¼ŒæŒ‰ç§©åˆå¹¶ï¼ˆæ ¸å¿ƒä¼˜åŒ–ï¼‰void unite(int x, int y) &#123;    int rx = find(x); // å…ˆæ‰¾ x çš„æ ¹    int ry = find(y); // å…ˆæ‰¾ y çš„æ ¹    if (rx == ry) return; // å·²åœ¨åŒä¸€é›†åˆï¼Œæ— éœ€åˆå¹¶    // æŒ‰ç§©åˆå¹¶ï¼šçŸ®æ ‘åˆå¹¶åˆ°é«˜æ ‘ä¸‹ï¼Œå‡å°‘æ ‘çš„é«˜åº¦    if (rank_[rx] &lt; rank_[ry]) &#123;        parent[rx] = ry;    &#125; else &#123;        parent[ry] = rx;        if (rank_[rx] == rank_[ry]) &#123;            rank_[rx]++; // ç§©ç›¸ç­‰æ—¶ï¼Œåˆå¹¶åç§©+1        &#125;    &#125;&#125;\n","slug":"æ¡¶ï¼šå€¼ä¸ä¸‹æ ‡","date":"2026-01-21T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"LHY"},{"id":"9014e3c6b93bd70c6ba3cd7677e22fa6","title":"ç¬¬23æ¬¡CCFCSP T4å­¦ä¹ ç¬”è®°","content":"é¢˜ç›®é“¾æ¥\n\n\n\n\n\n\n\n\nhttps://www.acwing.com/problem/content/4012/\né¢˜è§£ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;const int maxn=50;using namespace std;double p[maxn+5];int book[maxn+5];int N,K;double dp[1000][70000];double dfs(int lev,int left,int state){//å±‚æ•°ï¼Œå‰©ä½™ç‰Œæ•°ï¼Œ01é€‰æˆ–è€…ä¸é€‰çš„çŠ¶æ€    if((lev-(N-left))/K&gt;=left)return lev;    double ans=0;    for(int i=0;i&lt;N;i++){        int temps;        if(book[i]==0){            book[i]=1;            temps=state|(1&lt;&lt;i);            if(dp[lev+1][temps]==0){                dp[lev+1][temps]=dfs(lev+1,left-1,temps);            }            ans+=p[i]*dp[lev+1][temps];            book[i]=0;        }        else{            if(dp[lev+1][state]==0){                dp[lev+1][state]=dfs(lev+1,left,state);            }            ans+=p[i]*dp[lev+1][state];        }    }    return ans;}int main(){    cin&gt;&gt;N&gt;&gt;K;    for(int i=0;i&lt;N;i++){        cin&gt;&gt;p[i];    }    double ans=0;    for(int i=0;i&lt;N;i++){        book[i]=1;        int st=(1&lt;&lt;i);        if(dp[1][st]==0){            dp[1][st]=dfs(1,N-1,st);        }        ans+=p[i]*dfs(1,N-1,st);        book[i]=0;    }    printf(\"%.10f\",ans);    return 0;}åŸæ–‡é“¾æ¥://blog.csdn.net/tongjingqi_/article/details/120831527\nç®—æ³•æŠ€æœ¯åŠå…¶å®ç°\n\n\n\n\n\n\n\n\nçŠ¶æ€å‹ç¼©ç”¨ä¸€ä¸ªäºŒè¿›åˆ¶ä¸‹nä½çš„æ•°å­—æ¥å­˜å‚¨æŸä¸ªåŒ…å«nä¸ªåªæœ‰0ï¼Œ1å­çŠ¶æ€çš„æ€»çŠ¶æ€\nå¯¹äºä¸€ä¸ªçŠ¶æ€iï¼Œcpp i = i | (1&lt;&lt;k) å³ç¬¬kä½è®¾ä¸º1cpp i = i &amp; ~(1 &lt;&lt; k) å³ç¬¬kä½è®¾ä¸º0\ncpp (i&gt;&gt;(k-1))%2 è¯¥è¡¨è¾¾å¼è¡¨ç¤ºç¬¬kä½çš„çŠ¶æ€ï¼Œç”¨äºè®¿é—®ç¬¬kä½\nç»éªŒåŠæ€è·¯è®°å½•æˆ‘çš„ä»£ç   123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 65536;int n,k;double p[20],ans;int i;//æ ‡è®°å½“å‰çŠ¶æ€double dp[80][N+5];//ç¬¬ä¸€ä¸ªå‚æ•°è¡¨ç¤ºæŠ½ç‰Œçš„æ¬¡æ•°ï¼Œç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºæŠ½åˆ°çš„ç‰Œçš„çŠ¶æ€ã€‚p[i][j]è¡¨ç¤ºâ€œæŠ½äº†jæ¬¡ï¼ŒæŠ½åˆ°äº†çŠ¶æ€ä¸ºiçš„ç‰Œæ—¶ï¼ŒæŠ½å®Œæ‰€æœ‰ç‰Œçš„æœŸæœ›æ¬¡æ•°\"bool search(int i,int j){//æŸ¥è¯¢iåœ¨ç¬¬jä½ä¸Šçš„çŠ¶æ€  bool s = (i&gt;&gt;j)%2;  return s;}double dfs(int cnt,int got,int i){//cntå­˜å‚¨å½“å‰æŠ½å¡çš„æ¬¡æ•°ï¼Œgotå­˜å‚¨æ‹¥æœ‰çš„å¡ç‰Œæ•°é‡ï¼Œiå­˜å‚¨æ‹¥æœ‰çš„å¡ç‰Œçš„çŠ¶æ€ï¼Œ    //dfs(i,j,k)è¡¨ç¤ºæŠ½äº†iæ¬¡å¡ï¼ŒæŠ½åˆ°äº†jå¼ ï¼Œæ‹¥æœ‰å¡ç‰‡çŠ¶æ€ä¸ºkæ—¶ï¼Œæ€»å…±æœŸæœ›éœ€è¦å¤šå°‘æ¬¡æ‰èƒ½æŠ½å®Œ    int coins = cnt - got;//coinså­˜å‚¨ç¡¬å¸çš„æ•°é‡    double ans = 0;    if(coins&gt;=k*(n-got)) return cnt;    for(int j=0;j&lt;n;j++){        int now = (i|(1&lt;&lt;j));        if(search(i,j)){            if(dp[cnt+1][i]==0) dp[cnt+1][i]=dfs(cnt+1,got,i);            ans += p[j]*dp[cnt+1][i];        }        else{            if(dp[cnt+1][now]==0) dp[cnt+1][now]=dfs(cnt+1,got+1,now);            ans += p[j]*dp[cnt+1][now];        }    }    return ans;}int main(){    cin&gt;&gt; n &gt;&gt; k;    for(int i=0;i&lt;n;i++) cin&gt;&gt;p[i];    double ans = 0;    for(int i=0;i&lt;n;i++){        dp[1][1&lt;&lt;i] = dfs(1,1,1&lt;&lt;i);        ans += p[i]*dp[1][1&lt;&lt;i];    }    cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; ans &lt;&lt; endl;    return 0;}\næ”¹è¿›  åŸé¢˜è§£ä¸­ï¼Œdfså‡½æ•°çš„ç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºæœªæŠ½åˆ°å¡ç‰‡çš„æ•°é‡ï¼Œåœ¨æˆ‘çš„ä»£ç ä¸­ï¼Œdfså‡½æ•°çš„ç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºå·²ç»æŠ½åˆ°å¡ç‰‡çš„æ•°é‡ã€‚  åŸé¢˜è§£ä½¿ç”¨booksæ•°ç»„å­˜å‚¨ä¹¦ç±åœ¨å½“å‰çš„é€’å½’é“¾ä¸­çš„è¢«æŠ½å–çŠ¶æ€ï¼›è€Œç”±äºè¯¥ä¿¡æ¯å·²ç»å­˜å‚¨åœ¨dfsçš„ç¬¬ä¸‰ä¸ªå‚æ•°é‡Œï¼Œæˆ‘é€‰æ‹©ç›´æ¥è§£ç ç¬¬ä¸‰ä¸ªå‚æ•°æ¥è·å–è¯¥ä¿¡æ¯ï¼Œé¿å…äº†ä¸å¿…è¦çš„å¯¹booksæ•°ç»„çš„ç»´æŠ¤å·¥ä½œã€‚\næ„Ÿå—  å³ä½¿çœ‹è¿‡é¢˜è§£ï¼Œè‡ªå·±ä¸Šæ‰‹å†™æ„Ÿå—è¿˜æ˜¯å¾ˆä¸ä¸€æ ·çš„ã€‚  æˆ‘ä¸€å¼€å§‹æƒ³æŠŠdfså‡½æ•°è®¾ç½®æˆæŸä¸ªæ¦‚ç‡ï¼Œå³dfs(i,j,k,â€¦)(æ­¤å¤„å¯èƒ½ç”¨åˆ°ä¸æ­¢ä¸‰ä¸ªå‚æ•°)è¡¨ç¤ºæŠ½äº†â€œå‚æ•°1â€æ¬¡ç‰Œï¼ŒæŠ½åˆ°äº†çŠ¶æ€ä¸ºâ€œå‚æ•°2â€çš„ç‰Œçš„æ¦‚ç‡ã€‚å¹¶ä¸”ï¼ŒæŠŠdp[i][j]è®¾ç½®ä¸ºæŠ½äº†iæ¬¡ç‰Œï¼ŒæŠ½åˆ°çŠ¶æ€ä¸ºjçš„ç‰Œçš„æ¦‚ç‡ã€‚  åæ¥è‹¦æ€ï¼Œå‘ç°è¿™ä¹ˆåšç›¸å½“äºæ˜¯è®¡ç®—  , å³æ¯æŠ½ä¸€æ¬¡å¡å°±ç®—ä¸€æ¬¡æ¦‚ç‡,  ï¼Œè€Œå½“å‰ä¸¤æ®µä»£ç çš„æ€è·¯åˆ™æ˜¯ ï¼Œè¿™ä¼šå¯¼è‡´è®¡ç®—åŠå…¶éº»çƒ¦ã€‚\n\n\n\n\n\n\n\n\n\nå¯å‘\n\nå› æ­¤ï¼Œè®¾ç½®dfså‡½æ•°æ—¶è¦æ³¨æ„è¿ç®—çš„æ–¹å‘ã€‚\nä¸Šé¢ä¸¤æ®µä»£ç çš„æ€è·¯ç›¸å½“äºæ˜¯\nè®¾ç½®dfså‡½æ•°ä¸ºâ€œæœ€ç»ˆçš„ç»“æœâ€\nç”±äºè¿™ä¸ªé¢˜ç›®ç»è¿‡æœ‰é™æ¬¡é€’å½’ï¼Œæ€»èƒ½å¾—åˆ°â€œæœ€ç»ˆçš„ç»“æœâ€ï¼Œæ‰€ä»¥æ€»èƒ½ç»“æŸ\næ˜¯ä»nowé¢å‘nextçš„\n\n\nè€Œé‚£ä¸ªé”™è¯¯çš„æ€è·¯åˆ†æ”¯æ€è·¯ç›¸å½“äºæ˜¯\nè®¾è®¡dfså‡½æ•°æ˜¯â€œä»è¿‡å»çš„ç»“æœå¾—åˆ°ç°åœ¨â€\nä»nowé¢å‘next\n\n\næ€»ä¹‹ï¼ŒDFSæŠ€æœ¯æ˜¯â€œååºä¾èµ–â€çš„ã€‚\nGemini:â€œå®ƒæ·±å…¥æ¢ç´¢ç›´åˆ°å¶å­èŠ‚ç‚¹ï¼ˆç»ˆç‚¹ï¼‰ï¼Œç„¶ååœ¨å›æº¯çš„è¿‡ç¨‹ä¸­ï¼Œé€å±‚æŠŠè®¡ç®—å¥½çš„ç»“æœå‘ä¸Šå¡«å……ã€‚è¿™æ˜¯ä¸€ç§**â€œè‡ªåº•å‘ä¸Šâ€**çš„æ±‡æ€»ï¼Œæ¯ä¸€ä¸ªçŠ¶æ€åªä¼šè¢«è®¡ç®—ä¸€æ¬¡ï¼ˆè®°å¿†åŒ–ä¿è¯äº†è¿™ä¸€ç‚¹ï¼‰ã€‚â€\n\n\n\n\n\n\n\n\næ€»ç»“\n\nä½¿ç”¨DFS:\næ‰¾æ ‘\né¢˜ç›®é—®é¢˜èƒ½å¦è½¬æ¢æˆâ€ä¸€è·¯å‘ä¸‹éå†å¶å­èŠ‚ç‚¹ï¼Œæœ€ç»ˆæŠµè¾¾æŸä¸ªç»ˆç‚¹åœæ­¢ï¼Œå†é€æ­¥å›æº¯â€\næ ¹æ®å…·ä½“æ€§è´¨è®¾ç½®DFSå‡½æ•°\n\n\n\n","slug":"ç¬¬23æ¬¡CCFCSP T4å­¦ä¹ ç¬”è®°","date":"2026-01-21T16:00:00.000Z","categories_index":"ç®—æ³•,CSPçœŸé¢˜","tags_index":"DFS,DP,çŠ¶æ€å‹ç¼©","author_index":"LHY"}]